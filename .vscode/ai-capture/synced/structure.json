[{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:12:35.484Z","tree_hash":"f211379002adbf0169130c0f05d948edf1b0b5fd71c32fa4e605a59bc9938fe8","added":[{"path":"assets/ride_hailing.xlsx","size":49230,"mtime":1765480334420,"ext":"xlsx"},{"path":"assets/Parking Lot.twbx","size":6526441,"mtime":1765480334385,"ext":"twbx"},{"path":"assets/plates.zip","size":16216330,"mtime":1765480334415,"ext":"zip"},{"path":"assets/.keep","size":1,"mtime":1765480334378,"ext":""},{"path":"assets/parking_plot.png","size":253889,"mtime":1765480334397,"ext":"png"},{"path":"assets/map.png","size":110650,"mtime":1765480334387,"ext":"png"},{"path":"assets/parking_animation.gif","size":5532848,"mtime":1765480334395,"ext":"gif"},{"path":".cursorindexingignore","size":110,"mtime":1765480342642,"ext":""},{"path":"ride_hailing.xlsx","size":49230,"mtime":1765480334461,"ext":"xlsx"},{"path":"plates/D7CN6Q.png","size":141521,"mtime":1765480334437,"ext":"png"},{"path":"plates/C2F6VN.png","size":138807,"mtime":1765480334432,"ext":"png"},{"path":"plates/WV610AS.png","size":251834,"mtime":1765480334456,"ext":"png"},{"path":"plates/FE0MYMN.png","size":119098,"mtime":1765480334445,"ext":"png"},{"path":"plates/NCEUQ4.png","size":244976,"mtime":1765480334450,"ext":"png"},{"path":"plates/DD0BVK.png","size":231367,"mtime":1765480334438,"ext":"png"},{"path":"plates/M1FNYM.png","size":83630,"mtime":1765480334449,"ext":"png"},{"path":"plates/NVXWSP.png","size":245427,"mtime":1765480334451,"ext":"png"},{"path":"plates/H3NFDTN.png","size":245068,"mtime":1765480334446,"ext":"png"},{"path":"plates/T9GUBH.png","size":232263,"mtime":1765480334454,"ext":"png"},{"path":"plates/ZPR5EQ.png","size":240261,"mtime":1765480334459,"ext":"png"},{"path":"plates/Q75Q706.png","size":88704,"mtime":1765480334453,"ext":"png"},{"path":"plates/JAS3UW.png","size":139414,"mtime":1765480334447,"ext":"png"},{"path":"plates/EU11YZ5.png","size":86458,"mtime":1765480334443,"ext":"png"},{"path":"plates/D2FBZ7.png","size":135162,"mtime":1765480334436,"ext":"png"},{"path":"plates/VS1CZZ6.png","size":184604,"mtime":1765480334456,"ext":"png"},{"path":"plates/LWPM9VY.png","size":253706,"mtime":1765480334449,"ext":"png"},{"path":"plates/VEWCKJ.png","size":119745,"mtime":1765480334456,"ext":"png"},{"path":"plates/LPJW7B.png","size":118817,"mtime":1765480334448,"ext":"png"},{"path":"plates/MH6YC8.png","size":89091,"mtime":1765480334450,"ext":"png"},{"path":"plates/ULSXU1N.png","size":182443,"mtime":1765480334454,"ext":"png"},{"path":"plates/B5RMPS.png","size":138505,"mtime":1765480334430,"ext":"png"},{"path":"plates/CSUAPXD.png","size":186309,"mtime":1765480334435,"ext":"png"},{"path":"plates/B4BR8T.png","size":119963,"mtime":1765480334430,"ext":"png"},{"path":"plates/ENV245.png","size":136741,"mtime":1765480334443,"ext":"png"},{"path":"plates/J2GUWH8.png","size":121270,"mtime":1765480334446,"ext":"png"},{"path":"plates/RHSDQR.png","size":139565,"mtime":1765480334453,"ext":"png"},{"path":"plates/NNLXDFC.png","size":238455,"mtime":1765480334451,"ext":"png"},{"path":"plates/F5SHUBE.png","size":119962,"mtime":1765480334444,"ext":"png"},{"path":"plates/QEM62SJ.png","size":121752,"mtime":1765480334453,"ext":"png"},{"path":"plates/F2NJ2W.png","size":118100,"mtime":1765480334444,"ext":"png"},{"path":"plates/J1ZPXN.png","size":136545,"mtime":1765480334446,"ext":"png"},{"path":"plates/ZJE033.png","size":239133,"mtime":1765480334458,"ext":"png"},{"path":"plates/CP5Q4M.png","size":89363,"mtime":1765480334434,"ext":"png"},{"path":"plates/GP93NR.png","size":140661,"mtime":1765480334446,"ext":"png"},{"path":"plates/XLCPAU8.png","size":252970,"mtime":1765480334457,"ext":"png"},{"path":"plates/CUQM88J.png","size":249810,"mtime":1765480334436,"ext":"png"},{"path":"plates/PCNHBH.png","size":231520,"mtime":1765480334451,"ext":"png"},{"path":"plates/DA7WK8.png","size":243177,"mtime":1765480334437,"ext":"png"},{"path":"plates/U7R1JP.png","size":175690,"mtime":1765480334454,"ext":"png"},{"path":"plates/NADRE5G.png","size":120813,"mtime":1765480334450,"ext":"png"},{"path":"plates/XNC6FCM.png","size":242314,"mtime":1765480334457,"ext":"png"},{"path":"plates/PFB594.png","size":232538,"mtime":1765480334452,"ext":"png"},{"path":"plates/KG6EW2.png","size":89461,"mtime":1765480334447,"ext":"png"},{"path":"plates/V73Q8J2.png","size":143920,"mtime":1765480334455,"ext":"png"},{"path":"plates/VBTXTM.png","size":178067,"mtime":1765480334455,"ext":"png"},{"path":"plates/JUMX3RJ.png","size":248185,"mtime":1765480334447,"ext":"png"},{"path":"plates/LLTYXL4.png","size":249205,"mtime":1765480334448,"ext":"png"},{"path":"plates/C7010N.png","size":85146,"mtime":1765480334432,"ext":"png"},{"path":"plates/CDBEJB.png","size":174697,"mtime":1765480334434,"ext":"png"},{"path":"plates/DHSQKAQ.png","size":119529,"mtime":1765480334438,"ext":"png"},{"path":"plates/FWZU4BU.png","size":139706,"mtime":1765480334445,"ext":"png"},{"path":"plates/E45LPU.png","size":134295,"mtime":1765480334443,"ext":"png"},{"path":"plates/WEBGFW1.png","size":86011,"mtime":1765480334456,"ext":"png"},{"path":"plates/EYELGK.png","size":83642,"mtime":1765480334444,"ext":"png"},{"path":"plates/MHKVP5.png","size":120192,"mtime":1765480334450,"ext":"png"},{"path":"plates/PKS29HK.png","size":242629,"mtime":1765480334452,"ext":"png"},{"path":"plates/NSTQGMR.png","size":184318,"mtime":1765480334451,"ext":"png"},{"path":"plates/UY767S.png","size":138706,"mtime":1765480334455,"ext":"png"},{"path":"plates/UUNJPK1.png","size":136920,"mtime":1765480334455,"ext":"png"},{"path":"plates/WASDD1C.png","size":184748,"mtime":1765480334456,"ext":"png"},{"path":"plates/H5BFXQR.png","size":120260,"mtime":1765480334446,"ext":"png"},{"path":"plates/A8EFRA5.png","size":138824,"mtime":1765480334429,"ext":"png"},{"path":"plates/X9A1NUG.png","size":89290,"mtime":1765480334457,"ext":"png"},{"path":"plates/M2GC6BR.png","size":142782,"mtime":1765480334449,"ext":"png"},{"path":"plates/K5RM40X.png","size":184771,"mtime":1765480334447,"ext":"png"},{"path":"plates/KGYDFK.png","size":85354,"mtime":1765480334448,"ext":"png"},{"path":"plates/PXAVN0E.png","size":184193,"mtime":1765480334452,"ext":"png"},{"path":"plates/XFCWC9.png","size":180415,"mtime":1765480334457,"ext":"png"},{"path":"plates/FEEN6D3.png","size":235557,"mtime":1765480334445,"ext":"png"},{"path":"plates/ALQWNF8.png","size":140989,"mtime":1765480334429,"ext":"png"},{"path":"plates/BQD3QCC.png","size":139180,"mtime":1765480334431,"ext":"png"},{"path":"plates/WB28BTE.png","size":88148,"mtime":1765480334456,"ext":"png"},{"path":"plates/HLTLM1.png","size":130915,"mtime":1765480334446,"ext":"png"},{"path":"plates/KK5UTE0.png","size":137813,"mtime":1765480334448,"ext":"png"},{"path":"plates/X7M262S.png","size":143047,"mtime":1765480334457,"ext":"png"},{"path":"plates/YGYHQM3.png","size":242183,"mtime":1765480334458,"ext":"png"},{"path":"plates/PJ5RM4.png","size":120211,"mtime":1765480334452,"ext":"png"},{"path":"plates/BC9EGM.png","size":121179,"mtime":1765480334431,"ext":"png"},{"path":"plates/UPS7402.png","size":186223,"mtime":1765480334455,"ext":"png"},{"path":"plates/JXPN4TF.png","size":137857,"mtime":1765480334447,"ext":"png"},{"path":"plates/C83S708.png","size":251088,"mtime":1765480334433,"ext":"png"},{"path":"plates/GIX3162.png","size":184369,"mtime":1765480334445,"ext":"png"},{"path":"plates/KTDPNX4.png","size":87454,"mtime":1765480334448,"ext":"png"},{"path":"plates/AE2DUT0.png","size":120363,"mtime":1765480334429,"ext":"png"},{"path":"plates/ZGYDJ5C.png","size":89532,"mtime":1765480334458,"ext":"png"},{"path":"plates/S3R7YP8.png","size":244654,"mtime":1765480334453,"ext":"png"},{"path":"plates/S1CWQEC.png","size":89498,"mtime":1765480334453,"ext":"png"},{"path":"plates/PPX97K.png","size":139610,"mtime":1765480334452,"ext":"png"},{"path":"plates/BUHUC1.png","size":117532,"mtime":1765480334431,"ext":"png"},{"path":"plates/B7F5T1Y.png","size":248043,"mtime":1765480334430,"ext":"png"},{"path":"plates/SQUCQ1.png","size":140293,"mtime":1765480334454,"ext":"png"},{"path":"plates/R53DE3X.png","size":248527,"mtime":1765480334453,"ext":"png"},{"path":"plates/XB8PYW.png","size":139192,"mtime":1765480334457,"ext":"png"},{"path":"plates/YY1PS2.png","size":236611,"mtime":1765480334458,"ext":"png"},{"path":"plates/JN2DF6.png","size":136942,"mtime":1765480334447,"ext":"png"},{"path":"plates/DV1K2Z.png","size":177258,"mtime":1765480334443,"ext":"png"},{"path":"plates/XP82WDL.png","size":243721,"mtime":1765480334458,"ext":"png"},{"path":"plates/SPQBUSK.png","size":120662,"mtime":1765480334454,"ext":"png"},{"path":"plates/MGGNAV.png","size":86897,"mtime":1765480334449,"ext":"png"},{"path":".github/.keep","size":0,"mtime":1765480334378,"ext":""},{"path":".github/workflows/claude-code-review.yml","size":1384,"mtime":1765480334378,"ext":"yml","content":"name: Claude Code Review\n\non:\n  pull_request:\n    branches:\n      - main\n    types: [opened, synchronize, reopened]\n\njobs:\n  claude-review:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      pull-requests: read\n      issues: read\n      id-token: write\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 1\n\n      - name: Run Claude Code Review\n        id: claude-review\n        uses: anthropics/claude-code-action@v1\n        with:\n          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}\n          prompt: |\n            REPO: ${{ github.repository }}\n            PR NUMBER: ${{ github.event.pull_request.number }}\n\n            Please review this pull request and provide feedback on:\n            - Code quality and best practices\n            - Potential bugs or issues\n            - Performance considerations\n            - Security concerns\n            - Test coverage\n\n            Use the repository's CLAUDE.md for guidance on style and conventions. Be constructive and helpful in your feedback.\n\n            Use `gh pr comment` with your Bash tool to leave your review as a comment on the PR.\n\n          claude_args: '--allowed-tools \"Bash(gh issue view:*),Bash(gh search:*),Bash(gh issue list:*),Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh pr list:*)\"'\n"},{"path":"README.md","size":202,"mtime":1765480334378,"ext":"md","content":"[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/0rtLjY3p)\n"},{"path":"backend/.keep","size":1,"mtime":1765480334420,"ext":""},{"path":"backend/frontend/.keep","size":1,"mtime":1765480334420,"ext":""},{"path":"streamlit_app.py","size":111,"mtime":1765480334461,"ext":"py","content":"import streamlit as st\n\nst.title(\"Mini Project 3 â€“ Parking Visualization\")\nst.image(\"parking_animation.gif\")\n"},{"path":"visualize_parking.py","size":5555,"mtime":1765480334461,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 2 seconds (duration = 2.0)\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=2.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 2 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"},{"path":"map.png","size":110650,"mtime":1765480334420,"ext":"png"},{"path":"requirements.txt","size":34,"mtime":1765480334461,"ext":"txt","content":"streamlit\npandas\nnumpy\nmatplotlib\n"},{"path":"parking_animation.gif","size":3340788,"mtime":1765480334428,"ext":"gif"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:21:50.926Z","tree_hash":"30d559bc90cd1bb09ee8aeb68ca03a992809d9f526957b6eae0f49883b2d9146","added":[],"modified":[{"path":"streamlit_app.py","size":4651,"mtime":1765480907736,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_data, plate_number, timestamp):\n        \"\"\"Calculate how long a plate has been in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all records for this spot and plate\n        spot_history = spot_data[\n            (spot_data['x'] == spot_data.iloc[0]['x']) & \n            (spot_data['y'] == spot_data.iloc[0]['y']) &\n            (spot_data['plate_number'] == plate_number) &\n            (spot_data['status'] == 'occupied')\n        ].sort_values('current_time')\n        \n        if len(spot_history) == 0:\n            return None\n        \n        # Find when this plate first arrived at this spot\n        first_arrival = spot_history['current_time'].min()\n        duration = timestamp - first_arrival\n        \n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(df, plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            status_color = \"ðŸ”´\"  # Red for occupied\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': status_color\n            })\n        else:\n            # Vacant spot\n            status_color = \"ðŸŸ¢\"  # Green for vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': status_color\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create a styled table\n        st.dataframe(\n            table_df,\n            use_container_width=True,\n            hide_index=True,\n            column_config={\n                \"Spot #\": st.column_config.NumberColumn(\"Spot #\", width=\"small\"),\n                \"License Plate\": st.column_config.TextColumn(\"License Plate\", width=\"medium\"),\n                \"Duration\": st.column_config.TextColumn(\"Duration\", width=\"medium\"),\n                \"Status\": st.column_config.TextColumn(\"Status\", width=\"small\")\n            }\n        )\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:22:05.936Z","tree_hash":"274fb0476a901901dcf6551e4dc05fbfc89e08c08693a92fdc88a8e44b2a470b","added":[],"modified":[{"path":"streamlit_app.py","size":5405,"mtime":1765480923083,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all records for this spot and plate, up to current timestamp\n        spot_history = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['plate_number'] == plate_number) &\n            (df['status'] == 'occupied') &\n            (df['current_time'] <= current_timestamp)\n        ].sort_values('current_time')\n        \n        if len(spot_history) == 0:\n            return None\n        \n        # Find when this plate first arrived at this spot\n        # Check for continuity - if there's a gap, it's a new arrival\n        first_arrival = None\n        prev_time = None\n        \n        for _, row in spot_history.iterrows():\n            if prev_time is None:\n                first_arrival = row['current_time']\n                prev_time = row['current_time']\n            else:\n                # Check if there's a gap (spot was vacant in between)\n                time_diff = (row['current_time'] - prev_time).total_seconds()\n                # If gap is more than the frame duration (2 seconds), it's a new arrival\n                if time_diff > 3:\n                    first_arrival = row['current_time']\n                prev_time = row['current_time']\n        \n        if first_arrival is None:\n            return None\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(df, plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            status_color = \"ðŸ”´\"  # Red for occupied\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': status_color\n            })\n        else:\n            # Vacant spot\n            status_color = \"ðŸŸ¢\"  # Green for vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': status_color\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create a styled table\n        st.dataframe(\n            table_df,\n            use_container_width=True,\n            hide_index=True,\n            column_config={\n                \"Spot #\": st.column_config.NumberColumn(\"Spot #\", width=\"small\"),\n                \"License Plate\": st.column_config.TextColumn(\"License Plate\", width=\"medium\"),\n                \"Duration\": st.column_config.TextColumn(\"Duration\", width=\"medium\"),\n                \"Status\": st.column_config.TextColumn(\"Status\", width=\"small\")\n            }\n        )\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:22:10.937Z","tree_hash":"38e4e234d9234e03ed3bd45bccd3a93753b07acc50ed00121d6c01439864cbf2","added":[],"modified":[{"path":"streamlit_app.py","size":5309,"mtime":1765480928102,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all records for this spot and plate, up to current timestamp\n        spot_history = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['plate_number'] == plate_number) &\n            (df['status'] == 'occupied') &\n            (df['current_time'] <= current_timestamp)\n        ].sort_values('current_time')\n        \n        if len(spot_history) == 0:\n            return None\n        \n        # Find when this plate first arrived at this spot\n        # Check for continuity - if there's a gap, it's a new arrival\n        first_arrival = None\n        prev_time = None\n        \n        for _, row in spot_history.iterrows():\n            if prev_time is None:\n                first_arrival = row['current_time']\n                prev_time = row['current_time']\n            else:\n                # Check if there's a gap (spot was vacant in between)\n                time_diff = (row['current_time'] - prev_time).total_seconds()\n                # If gap is more than the frame duration (2 seconds), it's a new arrival\n                if time_diff > 3:\n                    first_arrival = row['current_time']\n                prev_time = row['current_time']\n        \n        if first_arrival is None:\n            return None\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create a styled table\n        st.dataframe(\n            table_df,\n            use_container_width=True,\n            hide_index=True,\n            column_config={\n                \"Spot #\": st.column_config.NumberColumn(\"Spot #\", width=\"small\"),\n                \"License Plate\": st.column_config.TextColumn(\"License Plate\", width=\"medium\"),\n                \"Duration\": st.column_config.TextColumn(\"Duration\", width=\"medium\"),\n                \"Status\": st.column_config.TextColumn(\"Status\", width=\"small\")\n            }\n        )\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:22:15.934Z","tree_hash":"fc4a95da633687a9d715bafbff480ca0898691d63fb712f7c0e4155aefdeb16a","added":[],"modified":[{"path":"streamlit_app.py","size":5744,"mtime":1765480932626,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all records for this spot and plate, up to current timestamp\n        spot_history = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['plate_number'] == plate_number) &\n            (df['status'] == 'occupied') &\n            (df['current_time'] <= current_timestamp)\n        ].sort_values('current_time')\n        \n        if len(spot_history) == 0:\n            return None\n        \n        # Find when this plate first arrived at this spot\n        # Check for continuity - if there's a gap, it's a new arrival\n        first_arrival = None\n        prev_time = None\n        \n        for _, row in spot_history.iterrows():\n            if prev_time is None:\n                first_arrival = row['current_time']\n                prev_time = row['current_time']\n            else:\n                # Check if there's a gap (spot was vacant in between)\n                time_diff = (row['current_time'] - prev_time).total_seconds()\n                # If gap is more than the frame duration (2 seconds), it's a new arrival\n                if time_diff > 3:\n                    first_arrival = row['current_time']\n                prev_time = row['current_time']\n        \n        if first_arrival is None:\n            return None\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Style the dataframe with colors\n        def style_status(val):\n            if val == 'Occupied':\n                return 'background-color: #ffcccc; color: #cc0000; font-weight: bold'\n            elif val == 'Vacant':\n                return 'background-color: #ccffcc; color: #006600; font-weight: bold'\n            return ''\n        \n        styled_df = table_df.style.applymap(\n            style_status, \n            subset=['Status']\n        )\n        \n        st.dataframe(\n            styled_df,\n            use_container_width=True,\n            hide_index=True,\n            column_config={\n                \"Spot #\": st.column_config.NumberColumn(\"Spot #\", width=\"small\"),\n                \"License Plate\": st.column_config.TextColumn(\"License Plate\", width=\"medium\"),\n                \"Duration\": st.column_config.TextColumn(\"Duration\", width=\"medium\"),\n                \"Status\": st.column_config.TextColumn(\"Status\", width=\"medium\")\n            }\n        )\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:22:40.950Z","tree_hash":"004f4f038260c1320bb389d10679addd827ff72c59a91f473951fdeeb3ecaab2","added":[],"modified":[{"path":"streamlit_app.py","size":6668,"mtime":1765480957532,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all records for this spot and plate, up to current timestamp\n        spot_history = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['plate_number'] == plate_number) &\n            (df['status'] == 'occupied') &\n            (df['current_time'] <= current_timestamp)\n        ].sort_values('current_time')\n        \n        if len(spot_history) == 0:\n            return None\n        \n        # Find when this plate first arrived at this spot\n        # Check for continuity - if there's a gap, it's a new arrival\n        first_arrival = None\n        prev_time = None\n        \n        for _, row in spot_history.iterrows():\n            if prev_time is None:\n                first_arrival = row['current_time']\n                prev_time = row['current_time']\n            else:\n                # Check if there's a gap (spot was vacant in between)\n                time_diff = (row['current_time'] - prev_time).total_seconds()\n                # If gap is more than the frame duration (2 seconds), it's a new arrival\n                if time_diff > 3:\n                    first_arrival = row['current_time']\n                prev_time = row['current_time']\n        \n        if first_arrival is None:\n            return None\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 14px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n        }\n        .parking-table td {\n            padding: 8px 10px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:22:50.955Z","tree_hash":"d8f1b7352fba91226b6c07da8bcc2acd07e692231b2df984edb1ab7c9b664895","added":[],"modified":[{"path":"streamlit_app.py","size":6668,"mtime":1765480970519,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all records for this spot and plate, up to current timestamp\n        spot_history = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['plate_number'] == plate_number) &\n            (df['status'] == 'occupied') &\n            (df['current_time'] <= current_timestamp)\n        ].sort_values('current_time')\n        \n        if len(spot_history) == 0:\n            return None\n        \n        # Find when this plate first arrived at this spot\n        # Check for continuity - if there's a gap, it's a new arrival\n        first_arrival = None\n        prev_time = None\n        \n        for _, row in spot_history.iterrows():\n            if prev_time is None:\n                first_arrival = row['current_time']\n                prev_time = row['current_time']\n            else:\n                # Check if there's a gap (spot was vacant in between)\n                time_diff = (row['current_time'] - prev_time).total_seconds()\n                # If gap is more than the frame duration (2 seconds), it's a new arrival\n                if time_diff > 3:\n                    first_arrival = row['current_time']\n                prev_time = row['current_time']\n        \n        if first_arrival is None:\n            return None\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 14px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n        }\n        .parking-table td {\n            padding: 8px 10px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:24:16.006Z","tree_hash":"00f43a1c86562b5382a3ea7f68dc24c947d4a78ec4028549ffa8201bf96025f3","added":[],"modified":[{"path":"streamlit_app.py","size":6754,"mtime":1765481053758,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all timestamps sorted in descending order\n        all_timestamps = sorted(df['current_time'].unique(), reverse=True)\n        \n        # Find the most recent time this plate was at this spot\n        first_arrival = None\n        consecutive = True\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        for timestamp in all_timestamps:\n            if timestamp > current_timestamp:\n                continue\n                \n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # If we've started tracking and now it's not this plate, we found the start\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 14px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n        }\n        .parking-table td {\n            padding: 8px 10px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:24:21.006Z","tree_hash":"b34d323ad8530ff964910ed25b4d223861a20599d495e252333cf9613995b306","added":[],"modified":[{"path":"streamlit_app.py","size":6909,"mtime":1765481057862,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all timestamps sorted in descending order\n        all_timestamps = sorted(df['current_time'].unique(), reverse=True)\n        \n        # Find the most recent time this plate was at this spot\n        first_arrival = None\n        consecutive = True\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        for timestamp in all_timestamps:\n            if timestamp > current_timestamp:\n                continue\n                \n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # If we've started tracking and now it's not this plate, we found the start\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 14px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n        }\n        .parking-table td {\n            padding: 8px 10px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:24:26.007Z","tree_hash":"82b1d47dcd2c82f726e0df19a0d61935d2694240300ed3ea268a51506793096d","added":[],"modified":[{"path":"streamlit_app.py","size":7577,"mtime":1765481063897,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all timestamps sorted in descending order\n        all_timestamps = sorted(df['current_time'].unique(), reverse=True)\n        \n        # Find the most recent time this plate was at this spot\n        first_arrival = None\n        consecutive = True\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        for timestamp in all_timestamps:\n            if timestamp > current_timestamp:\n                continue\n                \n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # If we've started tracking and now it's not this plate, we found the start\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 14px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n        }\n        .parking-table td {\n            padding: 8px 10px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:24:31.015Z","tree_hash":"3bac6089c9f5daf0304ee5ab1acdc8545342947000f7ac0f0a041f88b6e5edc7","added":[],"modified":[{"path":"streamlit_app.py","size":7945,"mtime":1765481068220,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all timestamps sorted in descending order\n        all_timestamps = sorted(df['current_time'].unique(), reverse=True)\n        \n        # Find the most recent time this plate was at this spot\n        first_arrival = None\n        consecutive = True\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        for timestamp in all_timestamps:\n            if timestamp > current_timestamp:\n                continue\n                \n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # If we've started tracking and now it's not this plate, we found the start\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n            max-height: 600px;\n            overflow-y: auto;\n            display: block;\n        }\n        .parking-table thead, .parking-table tbody {\n            display: block;\n        }\n        .parking-table tbody {\n            max-height: 500px;\n            overflow-y: auto;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n        }\n        .parking-table td {\n            padding: 8px 10px;\n            border-bottom: 1px solid #eee;\n            width: 25%;\n        }\n        .parking-table th {\n            width: 25%;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:24:41.025Z","tree_hash":"3086601450c9c426d7a42af1f0aa4be914ec76c9f84afcf9bcdc6cc1f3f8ae79","added":[],"modified":[{"path":"streamlit_app.py","size":7871,"mtime":1765481078390,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all timestamps sorted in descending order\n        all_timestamps = sorted(df['current_time'].unique(), reverse=True)\n        \n        # Find the most recent time this plate was at this spot\n        first_arrival = None\n        consecutive = True\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        for timestamp in all_timestamps:\n            if timestamp > current_timestamp:\n                continue\n                \n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # If we've started tracking and now it's not this plate, we found the start\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            background-color: #f0f0f0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:24:46.030Z","tree_hash":"eb09cb79dec776c85e64e6717b6098cc3c931fa83c09144ffe2a3bb24e8c8e8d","added":[],"modified":[{"path":"streamlit_app.py","size":7870,"mtime":1765481085658,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return None\n        \n        # Get all timestamps sorted in descending order\n        all_timestamps = sorted(df['current_time'].unique(), reverse=True)\n        \n        # Find the most recent time this plate was at this spot\n        first_arrival = None\n        consecutive = True\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        for timestamp in all_timestamps:\n            if timestamp > current_timestamp:\n                continue\n                \n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # If we've started tracking and now it's not this plate, we found the start\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:25:01.032Z","tree_hash":"d99b283f5636aa2203abc5289ec42087f585fd59cc29de3e79b1f73e790a1c51","added":[{"path":"test_dashboard_logic.py","size":0,"mtime":1765481100788,"ext":"py","content":"\"\"\"\nTest script to validate dashboard logic without running Streamlit\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\n\n# Load the data\ndf = pd.read_excel('ride_hailing.xlsx')\ndf['current_time'] = pd.to_datetime(df['current_time'])\ndf['status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\nprint(f\"Data loaded: {len(df)} rows\")\nprint(f\"Columns: {df.columns.tolist()}\")\nprint(f\"Unique timestamps: {len(df['current_time'].unique())}\")\nprint(f\"Date range: {df['current_time'].min()} to {df['current_time'].max()}\")\n\n# Get unique parking spots\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\nprint(f\"\\nUnique parking spots: {len(unique_spots)}\")\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\nprint(f\"\\nLatest timestamp: {latest_timestamp}\")\n\n# Get current state\ncurrent_data = df[df['current_time'] == latest_timestamp].copy()\ncurrent_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n\nprint(f\"\\nCurrent state (latest timestamp):\")\nprint(f\"Occupied spots: {len(current_data[current_data['status'] == 'occupied'])}\")\nprint(f\"Vacant spots: {len(current_data[current_data['status'] == 'vacant'])}\")\n\n# Test duration calculation for one spot\nif len(current_data[current_data['status'] == 'occupied']) > 0:\n    test_spot = current_data[current_data['status'] == 'occupied'].iloc[0]\n    print(f\"\\nTesting duration calculation for:\")\n    print(f\"  Spot: ({test_spot['x']}, {test_spot['y']})\")\n    print(f\"  Plate: {test_spot['plate_number']}\")\n    \n    # Simple duration calculation test\n    spot_history = df[\n        (df['x'] == test_spot['x']) & \n        (df['y'] == test_spot['y']) &\n        (df['plate_number'] == test_spot['plate_number']) &\n        (df['status'] == 'occupied')\n    ].sort_values('current_time')\n    \n    print(f\"  Records for this plate at this spot: {len(spot_history)}\")\n    if len(spot_history) > 0:\n        first_arrival = spot_history['current_time'].min()\n        duration = latest_timestamp - first_arrival\n        print(f\"  First arrival: {first_arrival}\")\n        print(f\"  Duration: {duration}\")\n        print(f\"  Duration (seconds): {duration.total_seconds()}\")\n\nprint(\"\\nâœ“ Dashboard logic test completed successfully!\")\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:25:06.032Z","tree_hash":"7d9ed48324a222e745a7bdf069f13fea5fe3684b390ba15377a1ae71756f9bbd","added":[],"modified":[{"path":"test_dashboard_logic.py","size":2374,"mtime":1765481100905,"ext":"py","content":"\"\"\"\nTest script to validate dashboard logic without running Streamlit\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\n\n# Load the data\ndf = pd.read_excel('ride_hailing.xlsx')\ndf['current_time'] = pd.to_datetime(df['current_time'])\ndf['status'] = df['reservation_id'].apply(\n    lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n)\n\nprint(f\"Data loaded: {len(df)} rows\")\nprint(f\"Columns: {df.columns.tolist()}\")\nprint(f\"Unique timestamps: {len(df['current_time'].unique())}\")\nprint(f\"Date range: {df['current_time'].min()} to {df['current_time'].max()}\")\n\n# Get unique parking spots\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\nprint(f\"\\nUnique parking spots: {len(unique_spots)}\")\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\nprint(f\"\\nLatest timestamp: {latest_timestamp}\")\n\n# Get current state\ncurrent_data = df[df['current_time'] == latest_timestamp].copy()\ncurrent_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n\nprint(f\"\\nCurrent state (latest timestamp):\")\nprint(f\"Occupied spots: {len(current_data[current_data['status'] == 'occupied'])}\")\nprint(f\"Vacant spots: {len(current_data[current_data['status'] == 'vacant'])}\")\n\n# Test duration calculation for one spot\nif len(current_data[current_data['status'] == 'occupied']) > 0:\n    test_spot = current_data[current_data['status'] == 'occupied'].iloc[0]\n    print(f\"\\nTesting duration calculation for:\")\n    print(f\"  Spot: ({test_spot['x']}, {test_spot['y']})\")\n    print(f\"  Plate: {test_spot['plate_number']}\")\n    \n    # Simple duration calculation test\n    spot_history = df[\n        (df['x'] == test_spot['x']) & \n        (df['y'] == test_spot['y']) &\n        (df['plate_number'] == test_spot['plate_number']) &\n        (df['status'] == 'occupied')\n    ].sort_values('current_time')\n    \n    print(f\"  Records for this plate at this spot: {len(spot_history)}\")\n    if len(spot_history) > 0:\n        first_arrival = spot_history['current_time'].min()\n        duration = latest_timestamp - first_arrival\n        print(f\"  First arrival: {first_arrival}\")\n        print(f\"  Duration: {duration}\")\n        print(f\"  Duration (seconds): {duration.total_seconds()}\")\n\nprint(\"\\nâœ“ Dashboard logic test completed successfully!\")\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:25:31.047Z","tree_hash":"e7ae5df67a32aee007ba993e1835521ecb58e7c7b4271ce1608278801be845ef","added":[],"modified":[{"path":"streamlit_app.py","size":7995,"mtime":1765481127874,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            if duration is not None:\n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            else:\n                duration_str = \"00:00:00\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:25:41.058Z","tree_hash":"f9dabe0284733c9db788e0d50b431ceb2d69455306c119eff6cfc19ef7421890","added":[],"modified":[{"path":"streamlit_app.py","size":7874,"mtime":1765481138705,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            # Format duration as HH:MM:SS\n            total_seconds = int(duration.total_seconds())\n            hours = total_seconds // 3600\n            minutes = (total_seconds % 3600) // 60\n            seconds = total_seconds % 60\n            duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:25:51.066Z","tree_hash":"20af61714b98476883e144b29677d97d8802e2f26d9899e08b6390a30d6bbcab","added":[],"modified":[],"removed":[{"path":"test_dashboard_logic.py","size":0,"mtime":0,"ext":"py","content":null}],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:26:06.075Z","tree_hash":"d2278d3a0b3ea84805b6e0e475bcaa52e57cc0f1f27974359750260e3619fb66","added":[],"modified":[{"path":"streamlit_app.py","size":7874,"mtime":1765481162383,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    st.image(\"parking_animation.gif\", use_container_width=True)\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_info = current_data[\n            (current_data['x'] == spot['x']) & \n            (current_data['y'] == spot['y'])\n        ]\n        \n        if len(spot_info) == 0:\n            continue\n            \n        spot_row = spot_info.iloc[0]\n        spot_number = int(spot['spot_number'])\n        \n        if spot_row['status'] == 'occupied':\n            plate_number = spot_row['plate_number']\n            duration = calculate_duration(spot['x'], spot['y'], plate_number, latest_timestamp)\n            \n            # Format duration as HH:MM:SS\n            total_seconds = int(duration.total_seconds())\n            hours = total_seconds // 3600\n            minutes = (total_seconds % 3600) // 60\n            seconds = total_seconds % 60\n            duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n            \n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': plate_number,\n                'Duration': duration_str,\n                'Status': 'Occupied'\n            })\n        else:\n            # Vacant spot\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:32:36.382Z","tree_hash":"95af9c182e438afbdcfffae7ad13040dd2d927fe1b782ab98d1e10cc7fe961be","added":[],"modified":[{"path":"streamlit_app.py","size":8798,"mtime":1765481554939,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Try to display the animated GIF\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Filter by search if provided\n    if search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        table_df = table_df[\n            table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n        ]\n    \n    # Display table with styling\n    if len(table_df) > 0:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:32:46.386Z","tree_hash":"d5f0e627ddc88ae8b7dc4cf8ade5344c9e8b78840aebc930c32811c90b9c8710","added":[],"modified":[{"path":"streamlit_app.py","size":8954,"mtime":1765481563750,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Try to display the animated GIF\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Filter by search if provided\n    if len(table_df) > 0 and search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        try:\n            table_df = table_df[\n                table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n            ]\n        except Exception as e:\n            st.warning(f\"Search error: {e}\")\n    \n    # Display table with styling\n    if len(table_df) > 0 and 'Spot #' in table_df.columns:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:33:01.403Z","tree_hash":"e0529a24b57d9fe049bd9313e8b44846e0a0be564933f4844b8a40e94c0117e5","added":[],"modified":[{"path":"streamlit_app.py","size":9214,"mtime":1765481579457,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Try to display the animated GIF\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Debug info (can be removed later)\n    with st.expander(\"Debug Info\", expanded=False):\n        st.write(f\"Total unique spots: {len(unique_spots)}\")\n        st.write(f\"Latest timestamp: {latest_timestamp}\")\n        st.write(f\"Data shape: {df.shape}\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Filter by search if provided\n    if len(table_df) > 0 and search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        try:\n            table_df = table_df[\n                table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n            ]\n        except Exception as e:\n            st.warning(f\"Search error: {e}\")\n    \n    # Display table with styling\n    if len(table_df) > 0 and 'Spot #' in table_df.columns:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:33:21.418Z","tree_hash":"aaa21a64a08e02ec966bf249defd1a4119642860e9e763942342d2d0536fac9c","added":[],"modified":[{"path":"streamlit_app.py","size":9472,"mtime":1765481600380,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Display the animated GIF - Streamlit should handle animation automatically\n        # If it's not animating, try refreshing the browser or clearing cache\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except FileNotFoundError:\n        st.error(\"parking_animation.gif not found. Please run visualize_parking.py first to generate it.\")\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Debug info (can be removed later)\n    with st.expander(\"Debug Info\", expanded=False):\n        st.write(f\"Total unique spots: {len(unique_spots)}\")\n        st.write(f\"Latest timestamp: {latest_timestamp}\")\n        st.write(f\"Data shape: {df.shape}\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Filter by search if provided\n    if len(table_df) > 0 and search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        try:\n            table_df = table_df[\n                table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n            ]\n        except Exception as e:\n            st.warning(f\"Search error: {e}\")\n    \n    # Display table with styling\n    if len(table_df) > 0 and 'Spot #' in table_df.columns:\n        # Add summary stats\n        occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n        vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n        total_count = len(table_df)\n        \n        st.metric(\"Occupied Spots\", f\"{occupied_count} / {total_count}\", \n                 delta=f\"{int(occupied_count/total_count*100)}% occupancy\" if total_count > 0 else \"0%\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:33:31.423Z","tree_hash":"47dfcba4e24d31206f395d244d934e7dccd63fe3d3a5526dd682ecec70b10adf","added":[],"modified":[{"path":"streamlit_app.py","size":9848,"mtime":1765481607008,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Display the animated GIF - Streamlit should handle animation automatically\n        # If it's not animating, try refreshing the browser or clearing cache\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except FileNotFoundError:\n        st.error(\"parking_animation.gif not found. Please run visualize_parking.py first to generate it.\")\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Debug info (can be removed later)\n    with st.expander(\"Debug Info\", expanded=False):\n        st.write(f\"Total unique spots: {len(unique_spots)}\")\n        st.write(f\"Latest timestamp: {latest_timestamp}\")\n        st.write(f\"Data shape: {df.shape}\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Filter by search if provided\n    if len(table_df) > 0 and search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        try:\n            table_df = table_df[\n                table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n            ]\n        except Exception as e:\n            st.warning(f\"Search error: {e}\")\n    \n    # Display table with styling\n    if len(table_df) > 0 and 'Spot #' in table_df.columns:\n        # Add summary stats (before filtering, to show all spots)\n        all_spots_data = pd.DataFrame(table_data) if len(table_data) > 0 else pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n        if len(all_spots_data) > 0 and 'Status' in all_spots_data.columns:\n            occupied_count_all = len(all_spots_data[all_spots_data['Status'] == 'Occupied'])\n            total_count_all = len(all_spots_data)\n            st.metric(\"Occupied Spots\", f\"{occupied_count_all} / {total_count_all}\", \n                     delta=f\"{int(occupied_count_all/total_count_all*100)}% occupancy\" if total_count_all > 0 else \"0%\")\n        \n        if len(table_df) == 0:\n            st.info(\"No spots match your search criteria. Try a different search term.\")\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:33:41.432Z","tree_hash":"f6154cb9850c4b9a9b234e9e7ac2af0b4ae3235859952ddd6363fdb8dd95bc5e","added":[],"modified":[{"path":"streamlit_app.py","size":9905,"mtime":1765481620906,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Display the animated GIF - Streamlit should handle animation automatically\n        # If it's not animating, try refreshing the browser or clearing cache\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except FileNotFoundError:\n        st.error(\"parking_animation.gif not found. Please run visualize_parking.py first to generate it.\")\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Debug info (can be removed later)\n    with st.expander(\"Debug Info\", expanded=False):\n        st.write(f\"Total unique spots: {len(unique_spots)}\")\n        st.write(f\"Latest timestamp: {latest_timestamp}\")\n        st.write(f\"Data shape: {df.shape}\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Calculate summary stats BEFORE filtering\n    all_spots_df = table_df.copy() if len(table_df) > 0 else pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    if len(all_spots_df) > 0 and 'Status' in all_spots_df.columns:\n        occupied_count_all = len(all_spots_df[all_spots_df['Status'] == 'Occupied'])\n        total_count_all = len(all_spots_df)\n        st.metric(\"Occupied Spots\", f\"{occupied_count_all} / {total_count_all}\", \n                 delta=f\"{int(occupied_count_all/total_count_all*100)}% occupancy\" if total_count_all > 0 else \"0%\")\n    \n    # Filter by search if provided\n    if len(table_df) > 0 and search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        try:\n            table_df = table_df[\n                table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n            ]\n        except Exception as e:\n            st.warning(f\"Search error: {e}\")\n    \n    # Display table with styling\n    if len(table_df) == 0:\n        if search_plate and search_plate.strip():\n            st.info(\"No spots match your search criteria. Try a different search term.\")\n        else:\n            st.warning(\"No parking spot data available. Please check your data file.\")\n    elif 'Spot #' in table_df.columns:\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:33:56.440Z","tree_hash":"148e7c7c96a35345994d106474b7b634979f404221f32a1eeb99c41ac1419b7d","added":[],"modified":[{"path":"streamlit_app.py","size":9905,"mtime":1765481631927,"ext":"py","content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\nst.set_page_config(page_title=\"Parking Dashboard\", layout=\"wide\")\n\nst.title(\"Mini Project 3 â€“ Parking Visualization Dashboard\")\n\n# Load the data\n@st.cache_data\ndef load_data():\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndf = load_data()\n\n# Get unique parking spots (by x, y coordinates) and assign spot numbers\nunique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\nunique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n\n# Get the latest timestamp\nlatest_timestamp = df['current_time'].max()\n\n# Create two columns layout\ncol1, col2 = st.columns([2, 1])\n\nwith col1:\n    st.subheader(\"Parking Animation\")\n    try:\n        # Display the animated GIF - Streamlit should handle animation automatically\n        # If it's not animating, try refreshing the browser or clearing cache\n        st.image(\"parking_animation.gif\", use_container_width=True)\n    except FileNotFoundError:\n        st.error(\"parking_animation.gif not found. Please run visualize_parking.py first to generate it.\")\n    except Exception as e:\n        st.error(f\"Error loading GIF: {e}\")\n        st.info(\"Make sure parking_animation.gif exists in the current directory\")\n\nwith col2:\n    st.subheader(\"Parking Spots Status\")\n    \n    # Debug info (can be removed later)\n    with st.expander(\"Debug Info\", expanded=False):\n        st.write(f\"Total unique spots: {len(unique_spots)}\")\n        st.write(f\"Latest timestamp: {latest_timestamp}\")\n        st.write(f\"Data shape: {df.shape}\")\n    \n    # Add a search/filter option\n    search_plate = st.text_input(\"Search by License Plate\", key=\"search_plate\", placeholder=\"Enter plate number...\")\n    \n    # Get current state (latest timestamp)\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    \n    # Merge with spot numbers\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate parking durations for occupied spots\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        # Get all timestamps up to current, sorted in descending order\n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        # Work backwards from current timestamp to find when this continuous period started\n        first_arrival = None\n        \n        for timestamp in all_timestamps:\n            # Check if this plate is at this spot at this timestamp\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                # No data for this timestamp at this spot, break continuity\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            # Check if this plate is occupying the spot\n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                # Plate is not at this spot, we've found when the continuous period started\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            # Plate just arrived or not found in history\n            return timedelta(0)\n            \n        duration = current_timestamp - first_arrival\n        return duration\n    \n    # Prepare table data - include ALL spots\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        # Find spot info at latest timestamp\n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                # Format duration as HH:MM:SS\n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                # Vacant spot\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            # Spot exists but no data at latest timestamp - assume vacant\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame for table\n    if len(table_data) > 0:\n        table_df = pd.DataFrame(table_data)\n        if 'Spot #' in table_df.columns:\n            table_df = table_df.sort_values('Spot #')\n    else:\n        # Fallback: create empty DataFrame with correct columns\n        table_df = pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    \n    # Calculate summary stats BEFORE filtering\n    all_spots_df = table_df.copy() if len(table_df) > 0 else pd.DataFrame(columns=['Spot #', 'License Plate', 'Duration', 'Status'])\n    if len(all_spots_df) > 0 and 'Status' in all_spots_df.columns:\n        occupied_count_all = len(all_spots_df[all_spots_df['Status'] == 'Occupied'])\n        total_count_all = len(all_spots_df)\n        st.metric(\"Occupied Spots\", f\"{occupied_count_all} / {total_count_all}\", \n                 delta=f\"{int(occupied_count_all/total_count_all*100)}% occupancy\" if total_count_all > 0 else \"0%\")\n    \n    # Filter by search if provided\n    if len(table_df) > 0 and search_plate and search_plate.strip():\n        search_term = search_plate.strip().upper()\n        try:\n            table_df = table_df[\n                table_df['License Plate'].astype(str).str.upper().str.contains(search_term, na=False)\n            ]\n        except Exception as e:\n            st.warning(f\"Search error: {e}\")\n    \n    # Display table with styling\n    if len(table_df) == 0:\n        if search_plate and search_plate.strip():\n            st.info(\"No spots match your search criteria. Try a different search term.\")\n        else:\n            st.warning(\"No parking spot data available. Please check your data file.\")\n    elif 'Spot #' in table_df.columns:\n        # Create HTML table with colored status indicators\n        html_table = \"\"\"\n        <style>\n        .table-container {\n            max-height: 550px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n        }\n        .parking-table {\n            width: 100%;\n            border-collapse: collapse;\n            font-family: Arial, sans-serif;\n            font-size: 13px;\n        }\n        .parking-table th {\n            background-color: #f0f0f0;\n            padding: 10px 8px;\n            text-align: left;\n            border-bottom: 2px solid #ddd;\n            font-weight: bold;\n            position: sticky;\n            top: 0;\n            z-index: 10;\n        }\n        .parking-table td {\n            padding: 8px;\n            border-bottom: 1px solid #eee;\n        }\n        .parking-table tr:hover {\n            background-color: #f5f5f5;\n        }\n        .status-occupied {\n            background-color: #ffcccc !important;\n            color: #cc0000;\n            font-weight: bold;\n            text-align: center;\n        }\n        .status-vacant {\n            background-color: #ccffcc !important;\n            color: #006600;\n            font-weight: bold;\n            text-align: center;\n        }\n        </style>\n        <div class=\"table-container\">\n        <table class=\"parking-table\">\n        <thead>\n            <tr>\n                <th>Spot #</th>\n                <th>License Plate</th>\n                <th>Duration</th>\n                <th>Status</th>\n            </tr>\n        </thead>\n        <tbody>\n        \"\"\"\n        \n        for _, row in table_df.iterrows():\n            status_class = \"status-occupied\" if row['Status'] == 'Occupied' else \"status-vacant\"\n            html_table += f\"\"\"\n            <tr>\n                <td>{int(row['Spot #'])}</td>\n                <td>{row['License Plate']}</td>\n                <td>{row['Duration']}</td>\n                <td class=\"{status_class}\">{row['Status']}</td>\n            </tr>\n            \"\"\"\n        \n        html_table += \"\"\"\n        </tbody>\n        </table>\n        </div>\n        \"\"\"\n        \n        st.markdown(html_table, unsafe_allow_html=True)\n        \n        # Display timestamp\n        st.caption(f\"Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}\")\n    else:\n        st.info(\"No parking data available\")\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:37:11.570Z","tree_hash":"d9961169dcc652ca1449c6374f74ecd7cab7d8f034d4a6f01e7375554abdef9a","added":[{"path":"test_dashboard_output.py","size":5378,"mtime":1765481830315,"ext":"py","content":"\"\"\"\nTest script to show what the dashboard would display\nThis simulates the dashboard logic and shows the output\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\n\nprint(\"=\" * 60)\nprint(\"DASHBOARD DATA PREVIEW\")\nprint(\"=\" * 60)\n\n# Load the data (same logic as dashboard)\ntry:\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    print(f\"\\nâœ“ Data loaded successfully\")\n    print(f\"  Total rows: {len(df)}\")\n    print(f\"  Unique timestamps: {len(df['current_time'].unique())}\")\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    print(f\"  Total parking spots: {len(unique_spots)}\")\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    print(f\"  Latest timestamp: {latest_timestamp}\")\n    \n    # Get current state\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate durations (simplified version)\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        first_arrival = None\n        for timestamp in all_timestamps:\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        return current_timestamp - first_arrival\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"\\n\" + \"=\" * 60)\n    print(\"PARKING SPOTS SUMMARY\")\n    print(\"=\" * 60)\n    print(f\"Occupied: {occupied_count} / {total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(f\"Vacant: {vacant_count} / {total_count}\")\n    \n    print(f\"\\n\" + \"=\" * 60)\n    print(\"PARKING SPOTS TABLE (first 20 rows)\")\n    print(\"=\" * 60)\n    print(table_df.head(20).to_string(index=False))\n    \n    if len(table_df) > 20:\n        print(f\"\\n... and {len(table_df) - 20} more spots\")\n    \n    print(f\"\\n\" + \"=\" * 60)\n    print(\"âœ“ Dashboard logic working correctly!\")\n    print(\"=\" * 60)\n    print(f\"\\nTo view the interactive dashboard, run:\")\n    print(f\"  streamlit run streamlit_app.py\")\n    print(f\"\\nThen open http://localhost:8501 in your browser\")\n    \nexcept FileNotFoundError as e:\n    print(f\"âœ— Error: {e}\")\n    print(\"Make sure you're in the correct directory with ride_hailing.xlsx\")\nexcept Exception as e:\n    print(f\"âœ— Error: {e}\")\n    import traceback\n    traceback.print_exc()\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:37:31.584Z","tree_hash":"3178cb05520bdfa626e96d0a1e882412b6d0de3f22492b2b443daa6f274b4d2e","added":[],"modified":[{"path":"test_dashboard_output.py","size":5378,"mtime":1765481848546,"ext":"py","content":"\"\"\"\nTest script to show what the dashboard would display\nThis simulates the dashboard logic and shows the output\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\n\nprint(\"=\" * 60)\nprint(\"DASHBOARD DATA PREVIEW\")\nprint(\"=\" * 60)\n\n# Load the data (same logic as dashboard)\ntry:\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    \n    print(f\"\\nâœ“ Data loaded successfully\")\n    print(f\"  Total rows: {len(df)}\")\n    print(f\"  Unique timestamps: {len(df['current_time'].unique())}\")\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    print(f\"  Total parking spots: {len(unique_spots)}\")\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    print(f\"  Latest timestamp: {latest_timestamp}\")\n    \n    # Get current state\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    # Calculate durations (simplified version)\n    def calculate_duration(spot_x, spot_y, plate_number, current_timestamp):\n        if pd.isna(plate_number):\n            return timedelta(0)\n        \n        all_timestamps = sorted(\n            [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n            reverse=True\n        )\n        \n        first_arrival = None\n        for timestamp in all_timestamps:\n            spot_at_time = df[\n                (df['x'] == spot_x) & \n                (df['y'] == spot_y) &\n                (df['current_time'] == timestamp)\n            ]\n            \n            if len(spot_at_time) == 0:\n                if first_arrival is not None:\n                    break\n                continue\n                \n            spot_status = spot_at_time.iloc[0]\n            \n            if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n                first_arrival = timestamp\n            else:\n                if first_arrival is not None:\n                    break\n        \n        if first_arrival is None:\n            return timedelta(0)\n            \n        return current_timestamp - first_arrival\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    # Create DataFrame\n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"\\n\" + \"=\" * 60)\n    print(\"PARKING SPOTS SUMMARY\")\n    print(\"=\" * 60)\n    print(f\"Occupied: {occupied_count} / {total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(f\"Vacant: {vacant_count} / {total_count}\")\n    \n    print(f\"\\n\" + \"=\" * 60)\n    print(\"PARKING SPOTS TABLE (first 20 rows)\")\n    print(\"=\" * 60)\n    print(table_df.head(20).to_string(index=False))\n    \n    if len(table_df) > 20:\n        print(f\"\\n... and {len(table_df) - 20} more spots\")\n    \n    print(f\"\\n\" + \"=\" * 60)\n    print(\"âœ“ Dashboard logic working correctly!\")\n    print(\"=\" * 60)\n    print(f\"\\nTo view the interactive dashboard, run:\")\n    print(f\"  streamlit run streamlit_app.py\")\n    print(f\"\\nThen open http://localhost:8501 in your browser\")\n    \nexcept FileNotFoundError as e:\n    print(f\"âœ— Error: {e}\")\n    print(\"Make sure you're in the correct directory with ride_hailing.xlsx\")\nexcept Exception as e:\n    print(f\"âœ— Error: {e}\")\n    import traceback\n    traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:40:06.682Z","tree_hash":"2ed3abc0de49296e8eb43a64ed1ce994d9351bbbde6e053a92aed18cf70c4d97","added":[{"path":"create_dashboard.py","size":9891,"mtime":1765482002013,"ext":"py","content":"\"\"\"\nCreate a static dashboard visualization showing parking status\nThis generates a single image/HTML file with the dashboard\n\"\"\"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom PIL import Image\nimport numpy as np\nfrom datetime import timedelta\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.table import Table\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_dashboard():\n    \"\"\"Create the dashboard visualization\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    print(f\"Processing {len(unique_spots)} parking spots...\")\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(df, spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Calculate summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"Occupied: {occupied_count}/{total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(\"Creating dashboard visualization...\")\n    \n    # Create figure with custom layout\n    fig = plt.figure(figsize=(20, 12))\n    gs = gridspec.GridSpec(2, 2, figure=fig, hspace=0.3, wspace=0.3,\n                          height_ratios=[1, 1], width_ratios=[2, 1])\n    \n    # Main title\n    fig.suptitle('Parking Dashboard - Mini Project 3', fontsize=24, fontweight='bold', y=0.98)\n    \n    # Left side: Parking animation (latest frame)\n    ax1 = fig.add_subplot(gs[:, 0])\n    \n    # Load and display the parking map\n    try:\n        bg_image = Image.open('map.png')\n        img_width, img_height = bg_image.size\n        ax1.imshow(bg_image, extent=[0, img_width, 0, img_height], aspect='equal', alpha=1.0, zorder=0)\n        \n        # Plot current state\n        plot_data = current_data\n        \n        # Plot vacant spots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax1.scatter(vacant_data['x'], vacant_data['y'], c='gray', \n                       label='Vacant', alpha=0.8, s=100, zorder=2, \n                       edgecolors='black', linewidths=1.5)\n        \n        # Plot occupied spots\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        if len(occupied_data) > 0:\n            ax1.scatter(occupied_data['x'], occupied_data['y'], c='red', \n                       label='Occupied', alpha=0.8, s=100, zorder=2, \n                       edgecolors='darkred', linewidths=1.5)\n        \n        ax1.set_xlim(0, img_width)\n        ax1.set_ylim(0, img_height)\n        ax1.set_title(f'Parking Status - {latest_timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}', \n                     fontsize=16, fontweight='bold', pad=15)\n        ax1.legend(loc='upper right', fontsize=12, framealpha=0.9)\n        ax1.set_xticks([])\n        ax1.set_yticks([])\n        ax1.set_facecolor('white')\n    except Exception as e:\n        ax1.text(0.5, 0.5, f'Error loading map: {e}', \n                ha='center', va='center', transform=ax1.transAxes)\n        ax1.set_facecolor('lightgray')\n    \n    # Right side: Summary metrics\n    ax2 = fig.add_subplot(gs[0, 1])\n    ax2.axis('off')\n    \n    # Summary text\n    summary_text = f\"\"\"\n    PARKING STATUS SUMMARY\n    \n    Total Spots: {total_count}\n    Occupied: {occupied_count}\n    Vacant: {vacant_count}\n    \n    Occupancy Rate: {int(occupied_count/total_count*100)}%\n    \n    Last Updated:\n    {latest_timestamp.strftime(\"%B %d, %Y\")}\n    {latest_timestamp.strftime(\"%I:%M %p\")}\n    \"\"\"\n    \n    ax2.text(0.1, 0.5, summary_text, fontsize=14, \n            verticalalignment='center', fontfamily='monospace',\n            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))\n    \n    # Right side: Parking spots table\n    ax3 = fig.add_subplot(gs[1, 1])\n    ax3.axis('off')\n    ax3.set_title('Parking Spots Table', fontsize=16, fontweight='bold', pad=10)\n    \n    # Create table\n    table_vals = []\n    colors = []\n    \n    # Limit rows for display (show first 30 spots or all if less)\n    display_df = table_df.head(30).copy()\n    \n    # Add header\n    table_vals.append(['Spot #', 'License Plate', 'Duration', 'Status'])\n    colors.append(['lightgray', 'lightgray', 'lightgray', 'lightgray'])\n    \n    for _, row in display_df.iterrows():\n        spot_num = str(int(row['Spot #']))\n        plate = str(row['License Plate'])\n        duration = str(row['Duration'])\n        status = row['Status']\n        \n        table_vals.append([spot_num, plate, duration, status])\n        \n        # Color code status\n        if status == 'Occupied':\n            colors.append(['white', 'white', 'white', '#ffcccc'])  # Red for occupied\n        else:\n            colors.append(['white', 'white', 'white', '#ccffcc'])  # Green for vacant\n    \n    # Create table\n    table = ax3.table(cellText=table_vals, cellLoc='left', loc='center',\n                     colWidths=[0.15, 0.35, 0.25, 0.25],\n                     cellColours=colors)\n    \n    table.auto_set_font_size(False)\n    table.set_fontsize(9)\n    table.scale(1, 1.5)\n    \n    # Style header\n    for i in range(4):\n        cell = table[(0, i)]\n        cell.set_text_props(weight='bold', fontsize=10)\n        cell.set_facecolor('#4a86e8')\n        cell.set_text_props(color='white')\n    \n    # Add note if more spots exist\n    if len(table_df) > 30:\n        ax3.text(0.5, -0.05, f'Showing 30 of {len(table_df)} spots', \n                ha='center', transform=ax3.transAxes, fontsize=10, style='italic')\n    \n    plt.tight_layout(rect=[0, 0, 1, 0.97])\n    \n    # Save dashboard\n    output_file = 'parking_dashboard.png'\n    plt.savefig(output_file, dpi=150, bbox_inches='tight', facecolor='white')\n    print(f\"\\nâœ“ Dashboard saved as: {output_file}\")\n    \n    # Also save as PDF for better quality\n    output_pdf = 'parking_dashboard.pdf'\n    plt.savefig(output_pdf, bbox_inches='tight', facecolor='white')\n    print(f\"âœ“ Dashboard saved as: {output_pdf}\")\n    \n    plt.close()\n    \n    return output_file, table_df\n\nif __name__ == \"__main__\":\n    try:\n        output_file, table_df = create_dashboard()\n        print(f\"\\n{'='*60}\")\n        print(\"Dashboard created successfully!\")\n        print(f\"{'='*60}\")\n        print(f\"\\nView the dashboard by opening: {output_file}\")\n        print(f\"\\nTable preview (first 10 spots):\")\n        print(table_df.head(10).to_string(index=False))\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:40:11.685Z","tree_hash":"30503cd17c4786e06dab699fc3db0269bd60b766fa3164c7ca3d0356037566ec","added":[],"modified":[{"path":"create_dashboard.py","size":9941,"mtime":1765482010664,"ext":"py","content":"\"\"\"\nCreate a static dashboard visualization showing parking status\nThis generates a single image/PDF file with the dashboard\n\"\"\"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom PIL import Image\nimport numpy as np\nfrom datetime import timedelta\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.table import Table\nimport matplotlib.offsetbox as offsetbox\nimport os\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_dashboard():\n    \"\"\"Create the dashboard visualization\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    print(f\"Processing {len(unique_spots)} parking spots...\")\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(df, spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Calculate summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"Occupied: {occupied_count}/{total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(\"Creating dashboard visualization...\")\n    \n    # Create figure with custom layout\n    fig = plt.figure(figsize=(20, 12))\n    gs = gridspec.GridSpec(2, 2, figure=fig, hspace=0.3, wspace=0.3,\n                          height_ratios=[1, 1], width_ratios=[2, 1])\n    \n    # Main title\n    fig.suptitle('Parking Dashboard - Mini Project 3', fontsize=24, fontweight='bold', y=0.98)\n    \n    # Left side: Parking animation (latest frame)\n    ax1 = fig.add_subplot(gs[:, 0])\n    \n    # Load and display the parking map\n    try:\n        bg_image = Image.open('map.png')\n        img_width, img_height = bg_image.size\n        ax1.imshow(bg_image, extent=[0, img_width, 0, img_height], aspect='equal', alpha=1.0, zorder=0)\n        \n        # Plot current state\n        plot_data = current_data\n        \n        # Plot vacant spots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax1.scatter(vacant_data['x'], vacant_data['y'], c='gray', \n                       label='Vacant', alpha=0.8, s=100, zorder=2, \n                       edgecolors='black', linewidths=1.5)\n        \n        # Plot occupied spots\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        if len(occupied_data) > 0:\n            ax1.scatter(occupied_data['x'], occupied_data['y'], c='red', \n                       label='Occupied', alpha=0.8, s=100, zorder=2, \n                       edgecolors='darkred', linewidths=1.5)\n        \n        ax1.set_xlim(0, img_width)\n        ax1.set_ylim(0, img_height)\n        ax1.set_title(f'Parking Status - {latest_timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}', \n                     fontsize=16, fontweight='bold', pad=15)\n        ax1.legend(loc='upper right', fontsize=12, framealpha=0.9)\n        ax1.set_xticks([])\n        ax1.set_yticks([])\n        ax1.set_facecolor('white')\n    except Exception as e:\n        ax1.text(0.5, 0.5, f'Error loading map: {e}', \n                ha='center', va='center', transform=ax1.transAxes)\n        ax1.set_facecolor('lightgray')\n    \n    # Right side: Summary metrics\n    ax2 = fig.add_subplot(gs[0, 1])\n    ax2.axis('off')\n    \n    # Summary text\n    summary_text = f\"\"\"\n    PARKING STATUS SUMMARY\n    \n    Total Spots: {total_count}\n    Occupied: {occupied_count}\n    Vacant: {vacant_count}\n    \n    Occupancy Rate: {int(occupied_count/total_count*100)}%\n    \n    Last Updated:\n    {latest_timestamp.strftime(\"%B %d, %Y\")}\n    {latest_timestamp.strftime(\"%I:%M %p\")}\n    \"\"\"\n    \n    ax2.text(0.1, 0.5, summary_text, fontsize=14, \n            verticalalignment='center', fontfamily='monospace',\n            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))\n    \n    # Right side: Parking spots table\n    ax3 = fig.add_subplot(gs[1, 1])\n    ax3.axis('off')\n    ax3.set_title('Parking Spots Table', fontsize=16, fontweight='bold', pad=10)\n    \n    # Create table\n    table_vals = []\n    colors = []\n    \n    # Limit rows for display (show first 30 spots or all if less)\n    display_df = table_df.head(30).copy()\n    \n    # Add header\n    table_vals.append(['Spot #', 'License Plate', 'Duration', 'Status'])\n    colors.append(['lightgray', 'lightgray', 'lightgray', 'lightgray'])\n    \n    for _, row in display_df.iterrows():\n        spot_num = str(int(row['Spot #']))\n        plate = str(row['License Plate'])\n        duration = str(row['Duration'])\n        status = row['Status']\n        \n        table_vals.append([spot_num, plate, duration, status])\n        \n        # Color code status\n        if status == 'Occupied':\n            colors.append(['white', 'white', 'white', '#ffcccc'])  # Red for occupied\n        else:\n            colors.append(['white', 'white', 'white', '#ccffcc'])  # Green for vacant\n    \n    # Create table\n    table = ax3.table(cellText=table_vals, cellLoc='left', loc='center',\n                     colWidths=[0.15, 0.35, 0.25, 0.25],\n                     cellColours=colors)\n    \n    table.auto_set_font_size(False)\n    table.set_fontsize(9)\n    table.scale(1, 1.5)\n    \n    # Style header\n    for i in range(4):\n        cell = table[(0, i)]\n        cell.set_text_props(weight='bold', fontsize=10)\n        cell.set_facecolor('#4a86e8')\n        cell.set_text_props(color='white')\n    \n    # Add note if more spots exist\n    if len(table_df) > 30:\n        ax3.text(0.5, -0.05, f'Showing 30 of {len(table_df)} spots', \n                ha='center', transform=ax3.transAxes, fontsize=10, style='italic')\n    \n    plt.tight_layout(rect=[0, 0, 1, 0.97])\n    \n    # Save dashboard\n    output_file = 'parking_dashboard.png'\n    plt.savefig(output_file, dpi=150, bbox_inches='tight', facecolor='white')\n    print(f\"\\nâœ“ Dashboard saved as: {output_file}\")\n    \n    # Also save as PDF for better quality\n    output_pdf = 'parking_dashboard.pdf'\n    plt.savefig(output_pdf, bbox_inches='tight', facecolor='white')\n    print(f\"âœ“ Dashboard saved as: {output_pdf}\")\n    \n    plt.close()\n    \n    return output_file, table_df\n\nif __name__ == \"__main__\":\n    try:\n        output_file, table_df = create_dashboard()\n        print(f\"\\n{'='*60}\")\n        print(\"Dashboard created successfully!\")\n        print(f\"{'='*60}\")\n        print(f\"\\nView the dashboard by opening: {output_file}\")\n        print(f\"\\nTable preview (first 10 spots):\")\n        print(table_df.head(10).to_string(index=False))\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:40:21.697Z","tree_hash":"27d165ba44a236e31babf9e0aa4b43cb6dc95374f82f194322f6de12903ae8d4","added":[],"modified":[{"path":"create_dashboard.py","size":11358,"mtime":1765482021404,"ext":"py","content":"\"\"\"\nCreate a static dashboard visualization showing parking status\nThis generates a single image/PDF file with the dashboard\n\"\"\"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom PIL import Image\nimport numpy as np\nfrom datetime import timedelta\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.table import Table\nimport matplotlib.offsetbox as offsetbox\nimport os\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_dashboard():\n    \"\"\"Create the dashboard visualization\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    print(f\"Processing {len(unique_spots)} parking spots...\")\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(df, spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Calculate summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"Occupied: {occupied_count}/{total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(\"Creating dashboard visualization...\")\n    \n    # Create figure with custom layout\n    fig = plt.figure(figsize=(20, 12))\n    gs = gridspec.GridSpec(2, 2, figure=fig, hspace=0.3, wspace=0.3,\n                          height_ratios=[1, 1], width_ratios=[2, 1])\n    \n    # Main title\n    fig.suptitle('Parking Dashboard - Mini Project 3', fontsize=24, fontweight='bold', y=0.98)\n    \n    # Left side: Parking animation (latest frame)\n    ax1 = fig.add_subplot(gs[:, 0])\n    \n    # Load and display the parking map\n    try:\n        bg_image = Image.open('map.png')\n        img_width, img_height = bg_image.size\n        ax1.imshow(bg_image, extent=[0, img_width, 0, img_height], aspect='equal', alpha=1.0, zorder=0)\n        \n        # Plot current state\n        plot_data = current_data\n        \n        # Plot vacant spots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax1.scatter(vacant_data['x'], vacant_data['y'], c='gray', \n                       label='Vacant', alpha=0.8, s=100, zorder=2, \n                       edgecolors='black', linewidths=1.5)\n        \n        # Plot occupied spots using license plate images (like original visualization)\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Try to load license plate image\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax1.add_artist(ab)\n                except Exception as e:\n                    # Fallback to red dot if image can't be loaded\n                    ax1.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # Fallback to red dot if image doesn't exist\n                ax1.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Add legend entry for occupied if we used dots\n        if len(occupied_data) > 0 and not any(os.path.exists(f'plates/{row[\"plate_number\"]}.png') \n                                               for _, row in occupied_data.iterrows()):\n            ax1.scatter([], [], c='red', s=100, label='Occupied', \n                       edgecolors='darkred', linewidths=1.5)\n        \n        ax1.set_xlim(0, img_width)\n        ax1.set_ylim(0, img_height)\n        ax1.set_title(f'Parking Status - {latest_timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}', \n                     fontsize=16, fontweight='bold', pad=15)\n        ax1.legend(loc='upper right', fontsize=12, framealpha=0.9)\n        ax1.set_xticks([])\n        ax1.set_yticks([])\n        ax1.set_facecolor('white')\n    except Exception as e:\n        ax1.text(0.5, 0.5, f'Error loading map: {e}', \n                ha='center', va='center', transform=ax1.transAxes)\n        ax1.set_facecolor('lightgray')\n    \n    # Right side: Summary metrics\n    ax2 = fig.add_subplot(gs[0, 1])\n    ax2.axis('off')\n    \n    # Summary text\n    summary_text = f\"\"\"\n    PARKING STATUS SUMMARY\n    \n    Total Spots: {total_count}\n    Occupied: {occupied_count}\n    Vacant: {vacant_count}\n    \n    Occupancy Rate: {int(occupied_count/total_count*100)}%\n    \n    Last Updated:\n    {latest_timestamp.strftime(\"%B %d, %Y\")}\n    {latest_timestamp.strftime(\"%I:%M %p\")}\n    \"\"\"\n    \n    ax2.text(0.1, 0.5, summary_text, fontsize=14, \n            verticalalignment='center', fontfamily='monospace',\n            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))\n    \n    # Right side: Parking spots table\n    ax3 = fig.add_subplot(gs[1, 1])\n    ax3.axis('off')\n    ax3.set_title('Parking Spots Table', fontsize=16, fontweight='bold', pad=10)\n    \n    # Create table\n    table_vals = []\n    colors = []\n    \n    # Limit rows for display (show first 30 spots or all if less)\n    display_df = table_df.head(30).copy()\n    \n    # Add header\n    table_vals.append(['Spot #', 'License Plate', 'Duration', 'Status'])\n    colors.append(['lightgray', 'lightgray', 'lightgray', 'lightgray'])\n    \n    for _, row in display_df.iterrows():\n        spot_num = str(int(row['Spot #']))\n        plate = str(row['License Plate'])\n        duration = str(row['Duration'])\n        status = row['Status']\n        \n        table_vals.append([spot_num, plate, duration, status])\n        \n        # Color code status\n        if status == 'Occupied':\n            colors.append(['white', 'white', 'white', '#ffcccc'])  # Red for occupied\n        else:\n            colors.append(['white', 'white', 'white', '#ccffcc'])  # Green for vacant\n    \n    # Create table\n    table = ax3.table(cellText=table_vals, cellLoc='left', loc='center',\n                     colWidths=[0.15, 0.35, 0.25, 0.25],\n                     cellColours=colors)\n    \n    table.auto_set_font_size(False)\n    table.set_fontsize(9)\n    table.scale(1, 1.5)\n    \n    # Style header\n    for i in range(4):\n        cell = table[(0, i)]\n        cell.set_text_props(weight='bold', fontsize=10)\n        cell.set_facecolor('#4a86e8')\n        cell.set_text_props(color='white')\n    \n    # Add note if more spots exist\n    if len(table_df) > 30:\n        ax3.text(0.5, -0.05, f'Showing 30 of {len(table_df)} spots', \n                ha='center', transform=ax3.transAxes, fontsize=10, style='italic')\n    \n    plt.tight_layout(rect=[0, 0, 1, 0.97])\n    \n    # Save dashboard\n    output_file = 'parking_dashboard.png'\n    plt.savefig(output_file, dpi=150, bbox_inches='tight', facecolor='white')\n    print(f\"\\nâœ“ Dashboard saved as: {output_file}\")\n    \n    # Also save as PDF for better quality\n    output_pdf = 'parking_dashboard.pdf'\n    plt.savefig(output_pdf, bbox_inches='tight', facecolor='white')\n    print(f\"âœ“ Dashboard saved as: {output_pdf}\")\n    \n    plt.close()\n    \n    return output_file, table_df\n\nif __name__ == \"__main__\":\n    try:\n        output_file, table_df = create_dashboard()\n        print(f\"\\n{'='*60}\")\n        print(\"Dashboard created successfully!\")\n        print(f\"{'='*60}\")\n        print(f\"\\nView the dashboard by opening: {output_file}\")\n        print(f\"\\nTable preview (first 10 spots):\")\n        print(table_df.head(10).to_string(index=False))\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:40:41.712Z","tree_hash":"44a11667673ae2d245db1fab28407f5f1cf678634f58886f6314e592a6898310","added":[],"modified":[{"path":"create_dashboard.py","size":11545,"mtime":1765482039686,"ext":"py","content":"\"\"\"\nCreate a static dashboard visualization showing parking status\nThis generates a single image/PDF file with the dashboard\n\"\"\"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom PIL import Image\nimport numpy as np\nfrom datetime import timedelta\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.table import Table\nimport matplotlib.offsetbox as offsetbox\nimport os\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_dashboard():\n    \"\"\"Create the dashboard visualization\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    print(f\"Processing {len(unique_spots)} parking spots...\")\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(df, spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Calculate summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"Occupied: {occupied_count}/{total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(\"Creating dashboard visualization...\")\n    \n    # Create figure with custom layout\n    fig = plt.figure(figsize=(20, 12))\n    gs = gridspec.GridSpec(2, 2, figure=fig, hspace=0.3, wspace=0.3,\n                          height_ratios=[1, 1], width_ratios=[2, 1])\n    \n    # Main title\n    fig.suptitle('Parking Dashboard - Mini Project 3', fontsize=24, fontweight='bold', y=0.98)\n    \n    # Left side: Parking animation (latest frame)\n    ax1 = fig.add_subplot(gs[:, 0])\n    \n    # Load and display the parking map\n    try:\n        bg_image = Image.open('map.png')\n        img_width, img_height = bg_image.size\n        ax1.imshow(bg_image, extent=[0, img_width, 0, img_height], aspect='equal', alpha=1.0, zorder=0)\n        \n        # Plot current state\n        plot_data = current_data\n        \n        # Plot vacant spots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax1.scatter(vacant_data['x'], vacant_data['y'], c='gray', \n                       label='Vacant', alpha=0.8, s=100, zorder=2, \n                       edgecolors='black', linewidths=1.5)\n        \n        # Plot occupied spots using license plate images (like original visualization)\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        has_occupied = len(occupied_data) > 0\n        used_images = False\n        used_dots = False\n        \n        if has_occupied:\n            for idx, row in occupied_data.iterrows():\n                plate_number = row['plate_number']\n                x_coord = row['x']\n                y_coord = row['y']\n                \n                # Try to load license plate image\n                plate_path = f'plates/{plate_number}.png'\n                if os.path.exists(plate_path):\n                    try:\n                        plate_img = Image.open(plate_path)\n                        plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                        \n                        imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                        ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                     frameon=False, pad=0)\n                        ax1.add_artist(ab)\n                        used_images = True\n                    except Exception as e:\n                        # Fallback to red dot if image can't be loaded\n                        ax1.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                                  edgecolors='darkred', linewidths=1.5)\n                        used_dots = True\n                else:\n                    # Fallback to red dot if image doesn't exist\n                    ax1.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n                    used_dots = True\n        \n        # Add legend entry for occupied\n        if has_occupied and used_dots:\n            ax1.scatter([], [], c='red', s=100, label='Occupied', \n                       edgecolors='darkred', linewidths=1.5)\n        \n        ax1.set_xlim(0, img_width)\n        ax1.set_ylim(0, img_height)\n        ax1.set_title(f'Parking Status - {latest_timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}', \n                     fontsize=16, fontweight='bold', pad=15)\n        ax1.legend(loc='upper right', fontsize=12, framealpha=0.9)\n        ax1.set_xticks([])\n        ax1.set_yticks([])\n        ax1.set_facecolor('white')\n    except Exception as e:\n        ax1.text(0.5, 0.5, f'Error loading map: {e}', \n                ha='center', va='center', transform=ax1.transAxes)\n        ax1.set_facecolor('lightgray')\n    \n    # Right side: Summary metrics\n    ax2 = fig.add_subplot(gs[0, 1])\n    ax2.axis('off')\n    \n    # Summary text\n    summary_text = f\"\"\"\n    PARKING STATUS SUMMARY\n    \n    Total Spots: {total_count}\n    Occupied: {occupied_count}\n    Vacant: {vacant_count}\n    \n    Occupancy Rate: {int(occupied_count/total_count*100)}%\n    \n    Last Updated:\n    {latest_timestamp.strftime(\"%B %d, %Y\")}\n    {latest_timestamp.strftime(\"%I:%M %p\")}\n    \"\"\"\n    \n    ax2.text(0.1, 0.5, summary_text, fontsize=14, \n            verticalalignment='center', fontfamily='monospace',\n            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))\n    \n    # Right side: Parking spots table\n    ax3 = fig.add_subplot(gs[1, 1])\n    ax3.axis('off')\n    ax3.set_title('Parking Spots Table', fontsize=16, fontweight='bold', pad=10)\n    \n    # Create table\n    table_vals = []\n    colors = []\n    \n    # Limit rows for display (show first 30 spots or all if less)\n    display_df = table_df.head(30).copy()\n    \n    # Add header\n    table_vals.append(['Spot #', 'License Plate', 'Duration', 'Status'])\n    colors.append(['lightgray', 'lightgray', 'lightgray', 'lightgray'])\n    \n    for _, row in display_df.iterrows():\n        spot_num = str(int(row['Spot #']))\n        plate = str(row['License Plate'])\n        duration = str(row['Duration'])\n        status = row['Status']\n        \n        table_vals.append([spot_num, plate, duration, status])\n        \n        # Color code status\n        if status == 'Occupied':\n            colors.append(['white', 'white', 'white', '#ffcccc'])  # Red for occupied\n        else:\n            colors.append(['white', 'white', 'white', '#ccffcc'])  # Green for vacant\n    \n    # Create table\n    table = ax3.table(cellText=table_vals, cellLoc='left', loc='center',\n                     colWidths=[0.15, 0.35, 0.25, 0.25],\n                     cellColours=colors)\n    \n    table.auto_set_font_size(False)\n    table.set_fontsize(9)\n    table.scale(1, 1.5)\n    \n    # Style header\n    for i in range(4):\n        cell = table[(0, i)]\n        cell.set_text_props(weight='bold', fontsize=10)\n        cell.set_facecolor('#4a86e8')\n        cell.set_text_props(color='white')\n    \n    # Add note if more spots exist\n    if len(table_df) > 30:\n        ax3.text(0.5, -0.05, f'Showing 30 of {len(table_df)} spots', \n                ha='center', transform=ax3.transAxes, fontsize=10, style='italic')\n    \n    plt.tight_layout(rect=[0, 0, 1, 0.97])\n    \n    # Save dashboard\n    output_file = 'parking_dashboard.png'\n    plt.savefig(output_file, dpi=150, bbox_inches='tight', facecolor='white')\n    print(f\"\\nâœ“ Dashboard saved as: {output_file}\")\n    \n    # Also save as PDF for better quality\n    output_pdf = 'parking_dashboard.pdf'\n    plt.savefig(output_pdf, bbox_inches='tight', facecolor='white')\n    print(f\"âœ“ Dashboard saved as: {output_pdf}\")\n    \n    plt.close()\n    \n    return output_file, table_df\n\nif __name__ == \"__main__\":\n    try:\n        output_file, table_df = create_dashboard()\n        print(f\"\\n{'='*60}\")\n        print(\"Dashboard created successfully!\")\n        print(f\"{'='*60}\")\n        print(f\"\\nView the dashboard by opening: {output_file}\")\n        print(f\"\\nTable preview (first 10 spots):\")\n        print(table_df.head(10).to_string(index=False))\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:41:01.720Z","tree_hash":"74d0ce6743d18b8cb64e6e2ff410ad36067ef276dd277bd69d8023f53a8b9e83","added":[],"modified":[{"path":"create_dashboard.py","size":11545,"mtime":1765482058538,"ext":"py","content":"\"\"\"\nCreate a static dashboard visualization showing parking status\nThis generates a single image/PDF file with the dashboard\n\"\"\"\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\nfrom PIL import Image\nimport numpy as np\nfrom datetime import timedelta\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.table import Table\nimport matplotlib.offsetbox as offsetbox\nimport os\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_dashboard():\n    \"\"\"Create the dashboard visualization\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get latest timestamp\n    latest_timestamp = df['current_time'].max()\n    current_data = df[df['current_time'] == latest_timestamp].copy()\n    current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n    \n    print(f\"Processing {len(unique_spots)} parking spots...\")\n    \n    # Prepare table data\n    table_data = []\n    for _, spot in unique_spots.iterrows():\n        spot_number = int(spot['spot_number'])\n        spot_x = spot['x']\n        spot_y = spot['y']\n        \n        spot_info = current_data[\n            (current_data['x'] == spot_x) & \n            (current_data['y'] == spot_y)\n        ]\n        \n        if len(spot_info) > 0:\n            spot_row = spot_info.iloc[0]\n            \n            if spot_row['status'] == 'occupied':\n                plate_number = spot_row['plate_number']\n                duration = calculate_duration(df, spot_x, spot_y, plate_number, latest_timestamp)\n                \n                total_seconds = int(duration.total_seconds())\n                hours = total_seconds // 3600\n                minutes = (total_seconds % 3600) // 60\n                seconds = total_seconds % 60\n                duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                \n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': plate_number,\n                    'Duration': duration_str,\n                    'Status': 'Occupied'\n                })\n            else:\n                table_data.append({\n                    'Spot #': spot_number,\n                    'License Plate': '-',\n                    'Duration': '-',\n                    'Status': 'Vacant'\n                })\n        else:\n            table_data.append({\n                'Spot #': spot_number,\n                'License Plate': '-',\n                'Duration': '-',\n                'Status': 'Vacant'\n            })\n    \n    table_df = pd.DataFrame(table_data)\n    table_df = table_df.sort_values('Spot #')\n    \n    # Calculate summary stats\n    occupied_count = len(table_df[table_df['Status'] == 'Occupied'])\n    vacant_count = len(table_df[table_df['Status'] == 'Vacant'])\n    total_count = len(table_df)\n    \n    print(f\"Occupied: {occupied_count}/{total_count} ({int(occupied_count/total_count*100)}%)\")\n    print(\"Creating dashboard visualization...\")\n    \n    # Create figure with custom layout\n    fig = plt.figure(figsize=(20, 12))\n    gs = gridspec.GridSpec(2, 2, figure=fig, hspace=0.3, wspace=0.3,\n                          height_ratios=[1, 1], width_ratios=[2, 1])\n    \n    # Main title\n    fig.suptitle('Parking Dashboard - Mini Project 3', fontsize=24, fontweight='bold', y=0.98)\n    \n    # Left side: Parking animation (latest frame)\n    ax1 = fig.add_subplot(gs[:, 0])\n    \n    # Load and display the parking map\n    try:\n        bg_image = Image.open('map.png')\n        img_width, img_height = bg_image.size\n        ax1.imshow(bg_image, extent=[0, img_width, 0, img_height], aspect='equal', alpha=1.0, zorder=0)\n        \n        # Plot current state\n        plot_data = current_data\n        \n        # Plot vacant spots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax1.scatter(vacant_data['x'], vacant_data['y'], c='gray', \n                       label='Vacant', alpha=0.8, s=100, zorder=2, \n                       edgecolors='black', linewidths=1.5)\n        \n        # Plot occupied spots using license plate images (like original visualization)\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        has_occupied = len(occupied_data) > 0\n        used_images = False\n        used_dots = False\n        \n        if has_occupied:\n            for idx, row in occupied_data.iterrows():\n                plate_number = row['plate_number']\n                x_coord = row['x']\n                y_coord = row['y']\n                \n                # Try to load license plate image\n                plate_path = f'plates/{plate_number}.png'\n                if os.path.exists(plate_path):\n                    try:\n                        plate_img = Image.open(plate_path)\n                        plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                        \n                        imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                        ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                     frameon=False, pad=0)\n                        ax1.add_artist(ab)\n                        used_images = True\n                    except Exception as e:\n                        # Fallback to red dot if image can't be loaded\n                        ax1.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                                  edgecolors='darkred', linewidths=1.5)\n                        used_dots = True\n                else:\n                    # Fallback to red dot if image doesn't exist\n                    ax1.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n                    used_dots = True\n        \n        # Add legend entry for occupied\n        if has_occupied and used_dots:\n            ax1.scatter([], [], c='red', s=100, label='Occupied', \n                       edgecolors='darkred', linewidths=1.5)\n        \n        ax1.set_xlim(0, img_width)\n        ax1.set_ylim(0, img_height)\n        ax1.set_title(f'Parking Status - {latest_timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}', \n                     fontsize=16, fontweight='bold', pad=15)\n        ax1.legend(loc='upper right', fontsize=12, framealpha=0.9)\n        ax1.set_xticks([])\n        ax1.set_yticks([])\n        ax1.set_facecolor('white')\n    except Exception as e:\n        ax1.text(0.5, 0.5, f'Error loading map: {e}', \n                ha='center', va='center', transform=ax1.transAxes)\n        ax1.set_facecolor('lightgray')\n    \n    # Right side: Summary metrics\n    ax2 = fig.add_subplot(gs[0, 1])\n    ax2.axis('off')\n    \n    # Summary text\n    summary_text = f\"\"\"\n    PARKING STATUS SUMMARY\n    \n    Total Spots: {total_count}\n    Occupied: {occupied_count}\n    Vacant: {vacant_count}\n    \n    Occupancy Rate: {int(occupied_count/total_count*100)}%\n    \n    Last Updated:\n    {latest_timestamp.strftime(\"%B %d, %Y\")}\n    {latest_timestamp.strftime(\"%I:%M %p\")}\n    \"\"\"\n    \n    ax2.text(0.1, 0.5, summary_text, fontsize=14, \n            verticalalignment='center', fontfamily='monospace',\n            bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.5))\n    \n    # Right side: Parking spots table\n    ax3 = fig.add_subplot(gs[1, 1])\n    ax3.axis('off')\n    ax3.set_title('Parking Spots Table', fontsize=16, fontweight='bold', pad=10)\n    \n    # Create table\n    table_vals = []\n    colors = []\n    \n    # Limit rows for display (show first 30 spots or all if less)\n    display_df = table_df.head(30).copy()\n    \n    # Add header\n    table_vals.append(['Spot #', 'License Plate', 'Duration', 'Status'])\n    colors.append(['lightgray', 'lightgray', 'lightgray', 'lightgray'])\n    \n    for _, row in display_df.iterrows():\n        spot_num = str(int(row['Spot #']))\n        plate = str(row['License Plate'])\n        duration = str(row['Duration'])\n        status = row['Status']\n        \n        table_vals.append([spot_num, plate, duration, status])\n        \n        # Color code status\n        if status == 'Occupied':\n            colors.append(['white', 'white', 'white', '#ffcccc'])  # Red for occupied\n        else:\n            colors.append(['white', 'white', 'white', '#ccffcc'])  # Green for vacant\n    \n    # Create table\n    table = ax3.table(cellText=table_vals, cellLoc='left', loc='center',\n                     colWidths=[0.15, 0.35, 0.25, 0.25],\n                     cellColours=colors)\n    \n    table.auto_set_font_size(False)\n    table.set_fontsize(9)\n    table.scale(1, 1.5)\n    \n    # Style header\n    for i in range(4):\n        cell = table[(0, i)]\n        cell.set_text_props(weight='bold', fontsize=10)\n        cell.set_facecolor('#4a86e8')\n        cell.set_text_props(color='white')\n    \n    # Add note if more spots exist\n    if len(table_df) > 30:\n        ax3.text(0.5, -0.05, f'Showing 30 of {len(table_df)} spots', \n                ha='center', transform=ax3.transAxes, fontsize=10, style='italic')\n    \n    plt.tight_layout(rect=[0, 0, 1, 0.97])\n    \n    # Save dashboard\n    output_file = 'parking_dashboard.png'\n    plt.savefig(output_file, dpi=150, bbox_inches='tight', facecolor='white')\n    print(f\"\\nâœ“ Dashboard saved as: {output_file}\")\n    \n    # Also save as PDF for better quality\n    output_pdf = 'parking_dashboard.pdf'\n    plt.savefig(output_pdf, bbox_inches='tight', facecolor='white')\n    print(f\"âœ“ Dashboard saved as: {output_pdf}\")\n    \n    plt.close()\n    \n    return output_file, table_df\n\nif __name__ == \"__main__\":\n    try:\n        output_file, table_df = create_dashboard()\n        print(f\"\\n{'='*60}\")\n        print(\"Dashboard created successfully!\")\n        print(f\"{'='*60}\")\n        print(f\"\\nView the dashboard by opening: {output_file}\")\n        print(f\"\\nTable preview (first 10 spots):\")\n        print(table_df.head(10).to_string(index=False))\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:46:07.060Z","tree_hash":"3ad11e331a4b8d39f8cf8ae62dc0031335fcd76e42ab4b56178b31770afa2a49","added":[{"path":"create_interactive_dashboard.py","size":15371,"mtime":1765482366765,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data)};\n        \n        // Current timestamp (latest)\n        let currentTimestamp = '{latest_timestamp.isoformat()}';\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with latest data\n        updateTable(currentTimestamp);\n        \n        // Optional: Auto-refresh table periodically (every 2 seconds to match GIF frame rate)\n        // Uncomment if you want the table to update automatically\n        /*\n        setInterval(() => {{\n            const timestamps = Object.keys(timestampData).sort();\n            const currentIndex = timestamps.indexOf(currentTimestamp);\n            const nextIndex = (currentIndex + 1) % timestamps.length;\n            currentTimestamp = timestamps[nextIndex];\n            updateTable(currentTimestamp);\n        }}, 2000);\n        */\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"modified":[{"path":"create_interactive_dashboard.py","size":15371,"mtime":1765482366765,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data)};\n        \n        // Current timestamp (latest)\n        let currentTimestamp = '{latest_timestamp.isoformat()}';\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with latest data\n        updateTable(currentTimestamp);\n        \n        // Optional: Auto-refresh table periodically (every 2 seconds to match GIF frame rate)\n        // Uncomment if you want the table to update automatically\n        /*\n        setInterval(() => {{\n            const timestamps = Object.keys(timestampData).sort();\n            const currentIndex = timestamps.indexOf(currentTimestamp);\n            const nextIndex = (currentIndex + 1) % timestamps.length;\n            currentTimestamp = timestamps[nextIndex];\n            updateTable(currentTimestamp);\n        }}, 2000);\n        */\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:46:16.999Z","tree_hash":"a798dc6ae84438c0c7c468a1d4f1a1a48045abddae2f3b2b7b0f2fd4cdddc75f","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":15381,"mtime":1765482372091,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Current timestamp (latest)\n        let currentTimestamp = '{latest_timestamp.isoformat()}';\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with latest data\n        updateTable(currentTimestamp);\n        \n        // Optional: Auto-refresh table periodically (every 2 seconds to match GIF frame rate)\n        // Uncomment if you want the table to update automatically\n        /*\n        setInterval(() => {{\n            const timestamps = Object.keys(timestampData).sort();\n            const currentIndex = timestamps.indexOf(currentTimestamp);\n            const nextIndex = (currentIndex + 1) % timestamps.length;\n            currentTimestamp = timestamps[nextIndex];\n            updateTable(currentTimestamp);\n        }}, 2000);\n        */\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:46:32.010Z","tree_hash":"68fb149befbf0a33308069057720a1831bd6ed1bdf89b708f06b99b84bd9f0ab","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":15381,"mtime":1765482389459,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Current timestamp (latest)\n        let currentTimestamp = '{latest_timestamp.isoformat()}';\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with latest data\n        updateTable(currentTimestamp);\n        \n        // Optional: Auto-refresh table periodically (every 2 seconds to match GIF frame rate)\n        // Uncomment if you want the table to update automatically\n        /*\n        setInterval(() => {{\n            const timestamps = Object.keys(timestampData).sort();\n            const currentIndex = timestamps.indexOf(currentTimestamp);\n            const nextIndex = (currentIndex + 1) % timestamps.length;\n            currentTimestamp = timestamps[nextIndex];\n            updateTable(currentTimestamp);\n        }}, 2000);\n        */\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:47:32.071Z","tree_hash":"8f79e4a087c3761113aed362c802f0cf53f04f04dce487f1db40108274e882d4","added":[{"path":"parking_dashboard.html","size":393556,"mtime":1765482449842,"ext":"html"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:50:47.199Z","tree_hash":"8fba1708f99016c3a06d65e8c24eec97875b6872f3c810111b31c5a56fbe9db4","added":[],"modified":[{"path":"visualize_parking.py","size":5583,"mtime":1765482643660,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 2 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:50:52.203Z","tree_hash":"8e1cd9fedefcd67392e41bf7f968368e8040c53f0d073c15bd01c4079070880a","added":[],"modified":[{"path":"visualize_parking.py","size":5583,"mtime":1765482651368,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:50:57.203Z","tree_hash":"1219b9119935e1d5a65f8d9b5a7ce46b23a28b499389bfc59699f93f2b12ee24","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":15522,"mtime":1765482654391,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    # Create sorted list of timestamp ISO strings for synchronization\n    sorted_timestamps = [ts.isoformat() for ts in all_timestamps]\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Current timestamp (latest)\n        let currentTimestamp = '{latest_timestamp.isoformat()}';\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with latest data\n        updateTable(currentTimestamp);\n        \n        // Optional: Auto-refresh table periodically (every 2 seconds to match GIF frame rate)\n        // Uncomment if you want the table to update automatically\n        /*\n        setInterval(() => {{\n            const timestamps = Object.keys(timestampData).sort();\n            const currentIndex = timestamps.indexOf(currentTimestamp);\n            const nextIndex = (currentIndex + 1) % timestamps.length;\n            currentTimestamp = timestamps[nextIndex];\n            updateTable(currentTimestamp);\n        }}, 2000);\n        */\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:51:02.210Z","tree_hash":"cceea748992b8fdf144d5a4bfa0f1e42ebf205be2acf380fdd53318b29785a28","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":15773,"mtime":1765482657997,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    # Create sorted list of timestamp ISO strings for synchronization\n    sorted_timestamps = [ts.isoformat() for ts in all_timestamps]\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Sorted list of all timestamps (matches GIF frame order)\n        const sortedTimestamps = {json.dumps(sorted_timestamps, indent=8)};\n        \n        // GIF frame duration in milliseconds (4 seconds per frame)\n        const FRAME_DURATION = 4000;\n        \n        // Current timestamp index (starts at 0)\n        let currentTimestampIndex = 0;\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with latest data\n        updateTable(currentTimestamp);\n        \n        // Optional: Auto-refresh table periodically (every 2 seconds to match GIF frame rate)\n        // Uncomment if you want the table to update automatically\n        /*\n        setInterval(() => {{\n            const timestamps = Object.keys(timestampData).sort();\n            const currentIndex = timestamps.indexOf(currentTimestamp);\n            const nextIndex = (currentIndex + 1) % timestamps.length;\n            currentTimestamp = timestamps[nextIndex];\n            updateTable(currentTimestamp);\n        }}, 2000);\n        */\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:51:07.214Z","tree_hash":"53945e4e57b89dd3ff664d99cc288138ef17784bf63a63a71687f0043b3a6680","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":16336,"mtime":1765482664332,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    # Create sorted list of timestamp ISO strings for synchronization\n    sorted_timestamps = [ts.isoformat() for ts in all_timestamps]\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Last updated: {latest_timestamp.strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Sorted list of all timestamps (matches GIF frame order)\n        const sortedTimestamps = {json.dumps(sorted_timestamps, indent=8)};\n        \n        // GIF frame duration in milliseconds (4 seconds per frame)\n        const FRAME_DURATION = 4000;\n        \n        // Current timestamp index (starts at 0)\n        let currentTimestampIndex = 0;\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with first timestamp (matches GIF start)\n        updateTable(sortedTimestamps[0]);\n        \n        // Synchronize table updates with GIF animation\n        // Update table every 4 seconds to match GIF frame rate\n        setInterval(() => {{\n            // Move to next timestamp (loop back to start when reaching end)\n            currentTimestampIndex = (currentTimestampIndex + 1) % sortedTimestamps.length;\n            const currentTimestamp = sortedTimestamps[currentTimestampIndex];\n            updateTable(currentTimestamp);\n        }}, FRAME_DURATION);\n        \n        // Reset to first frame when GIF loops (GIF loop detection is tricky, so we'll sync manually)\n        // The GIF loops, so we reset our index to match\n        const gifElement = document.getElementById('parkingGif');\n        if (gifElement) {{\n            // Reset to first frame every GIF loop cycle (60 frames * 4 seconds = 240 seconds)\n            const gifLoopDuration = sortedTimestamps.length * FRAME_DURATION;\n            setInterval(() => {{\n                currentTimestampIndex = 0;\n                updateTable(sortedTimestamps[0]);\n            }}, gifLoopDuration);\n        }}\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:51:12.230Z","tree_hash":"d1f90bd9d5ee71eb14b8695328a8e2d006258dfaed25d54cadb1b68fb3d8d7f4","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":16329,"mtime":1765482671884,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    # Create sorted list of timestamp ISO strings for synchronization\n    sorted_timestamps = [ts.isoformat() for ts in all_timestamps]\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Time: {all_timestamps[0].strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Sorted list of all timestamps (matches GIF frame order)\n        const sortedTimestamps = {json.dumps(sorted_timestamps, indent=8)};\n        \n        // GIF frame duration in milliseconds (4 seconds per frame)\n        const FRAME_DURATION = 4000;\n        \n        // Current timestamp index (starts at 0)\n        let currentTimestampIndex = 0;\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Last updated: ' + timestampStr;\n        }}\n        \n        // Initialize table with first timestamp (matches GIF start)\n        updateTable(sortedTimestamps[0]);\n        \n        // Synchronize table updates with GIF animation\n        // Update table every 4 seconds to match GIF frame rate\n        setInterval(() => {{\n            // Move to next timestamp (loop back to start when reaching end)\n            currentTimestampIndex = (currentTimestampIndex + 1) % sortedTimestamps.length;\n            const currentTimestamp = sortedTimestamps[currentTimestampIndex];\n            updateTable(currentTimestamp);\n        }}, FRAME_DURATION);\n        \n        // Reset to first frame when GIF loops (GIF loop detection is tricky, so we'll sync manually)\n        // The GIF loops, so we reset our index to match\n        const gifElement = document.getElementById('parkingGif');\n        if (gifElement) {{\n            // Reset to first frame every GIF loop cycle (60 frames * 4 seconds = 240 seconds)\n            const gifLoopDuration = sortedTimestamps.length * FRAME_DURATION;\n            setInterval(() => {{\n                currentTimestampIndex = 0;\n                updateTable(sortedTimestamps[0]);\n            }}, gifLoopDuration);\n        }}\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:51:17.225Z","tree_hash":"f59e08fd8ff604d5084576db8a08c69320dbcc62105405ab0aff4f0ac7eac76d","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":16321,"mtime":1765482675467,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    # Create sorted list of timestamp ISO strings for synchronization\n    sorted_timestamps = [ts.isoformat() for ts in all_timestamps]\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Time: {all_timestamps[0].strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Sorted list of all timestamps (matches GIF frame order)\n        const sortedTimestamps = {json.dumps(sorted_timestamps, indent=8)};\n        \n        // GIF frame duration in milliseconds (4 seconds per frame)\n        const FRAME_DURATION = 4000;\n        \n        // Current timestamp index (starts at 0)\n        let currentTimestampIndex = 0;\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Time: ' + timestampStr;\n        }}\n        \n        // Initialize table with first timestamp (matches GIF start)\n        updateTable(sortedTimestamps[0]);\n        \n        // Synchronize table updates with GIF animation\n        // Update table every 4 seconds to match GIF frame rate\n        setInterval(() => {{\n            // Move to next timestamp (loop back to start when reaching end)\n            currentTimestampIndex = (currentTimestampIndex + 1) % sortedTimestamps.length;\n            const currentTimestamp = sortedTimestamps[currentTimestampIndex];\n            updateTable(currentTimestamp);\n        }}, FRAME_DURATION);\n        \n        // Reset to first frame when GIF loops (GIF loop detection is tricky, so we'll sync manually)\n        // The GIF loops, so we reset our index to match\n        const gifElement = document.getElementById('parkingGif');\n        if (gifElement) {{\n            // Reset to first frame every GIF loop cycle (60 frames * 4 seconds = 240 seconds)\n            const gifLoopDuration = sortedTimestamps.length * FRAME_DURATION;\n            setInterval(() => {{\n                currentTimestampIndex = 0;\n                updateTable(sortedTimestamps[0]);\n            }}, gifLoopDuration);\n        }}\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:51:27.222Z","tree_hash":"464d04fcca75f39acd5e5fb5c291b02afd312388d47aca1e42a021c17f10b1e3","added":[],"modified":[{"path":"create_interactive_dashboard.py","size":16321,"mtime":1765482683701,"ext":"py","content":"\"\"\"\nCreate an interactive HTML dashboard with animated GIF and live-updating table\n\"\"\"\nimport pandas as pd\nfrom datetime import timedelta\nimport json\n\ndef load_data():\n    \"\"\"Load and process parking data\"\"\"\n    df = pd.read_excel('ride_hailing.xlsx')\n    df['current_time'] = pd.to_datetime(df['current_time'])\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n    return df\n\ndef calculate_duration(df, spot_x, spot_y, plate_number, current_timestamp):\n    \"\"\"Calculate how long a plate has been continuously in a spot\"\"\"\n    if pd.isna(plate_number):\n        return timedelta(0)\n    \n    all_timestamps = sorted(\n        [ts for ts in df['current_time'].unique() if ts <= current_timestamp],\n        reverse=True\n    )\n    \n    first_arrival = None\n    \n    for timestamp in all_timestamps:\n        spot_at_time = df[\n            (df['x'] == spot_x) & \n            (df['y'] == spot_y) &\n            (df['current_time'] == timestamp)\n        ]\n        \n        if len(spot_at_time) == 0:\n            if first_arrival is not None:\n                break\n            continue\n            \n        spot_status = spot_at_time.iloc[0]\n        \n        if spot_status['status'] == 'occupied' and spot_status['plate_number'] == plate_number:\n            first_arrival = timestamp\n        else:\n            if first_arrival is not None:\n                break\n    \n    if first_arrival is None:\n        return timedelta(0)\n        \n    return current_timestamp - first_arrival\n\ndef create_interactive_dashboard():\n    \"\"\"Create interactive HTML dashboard\"\"\"\n    print(\"Loading data...\")\n    df = load_data()\n    \n    # Get unique parking spots\n    unique_spots = df[['x', 'y']].drop_duplicates().sort_values(['y', 'x']).reset_index(drop=True)\n    unique_spots['spot_number'] = range(1, len(unique_spots) + 1)\n    \n    # Get all timestamps\n    all_timestamps = sorted(df['current_time'].unique())\n    \n    print(f\"Processing {len(unique_spots)} parking spots across {len(all_timestamps)} timestamps...\")\n    \n    # Create data for each timestamp\n    timestamp_data = {}\n    \n    for timestamp in all_timestamps:\n        current_data = df[df['current_time'] == timestamp].copy()\n        current_data = current_data.merge(unique_spots, on=['x', 'y'], how='left')\n        \n        spots_data = []\n        for _, spot in unique_spots.iterrows():\n            spot_number = int(spot['spot_number'])\n            spot_x = spot['x']\n            spot_y = spot['y']\n            \n            spot_info = current_data[\n                (current_data['x'] == spot_x) & \n                (current_data['y'] == spot_y)\n            ]\n            \n            spot_data = {\n                'spot_number': spot_number,\n                'status': 'vacant',\n                'license_plate': None,\n                'duration': '00:00:00'\n            }\n            \n            if len(spot_info) > 0:\n                spot_row = spot_info.iloc[0]\n                \n                if spot_row['status'] == 'occupied':\n                    plate_number = spot_row['plate_number']\n                    duration = calculate_duration(df, spot_x, spot_y, plate_number, timestamp)\n                    \n                    total_seconds = int(duration.total_seconds())\n                    hours = total_seconds // 3600\n                    minutes = (total_seconds % 3600) // 60\n                    seconds = total_seconds % 60\n                    duration_str = f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n                    \n                    spot_data = {\n                        'spot_number': spot_number,\n                        'status': 'occupied',\n                        'license_plate': str(plate_number),\n                        'duration': duration_str\n                    }\n            \n            spots_data.append(spot_data)\n        \n        timestamp_data[timestamp.isoformat()] = spots_data\n    \n    # Get latest timestamp data for initial display\n    latest_timestamp = all_timestamps[-1]\n    latest_data = timestamp_data[latest_timestamp.isoformat()]\n    \n    # Calculate summary stats for latest\n    occupied_count = sum(1 for s in latest_data if s['status'] == 'occupied')\n    total_count = len(latest_data)\n    \n    # Create sorted list of timestamp ISO strings for synchronization\n    sorted_timestamps = [ts.isoformat() for ts in all_timestamps]\n    \n    print(f\"Creating interactive HTML dashboard...\")\n    \n    # Create HTML content\n    html_content = f\"\"\"\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Parking Dashboard - Interactive</title>\n    <style>\n        * {{\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }}\n        \n        body {{\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f5f5f5;\n            padding: 20px;\n        }}\n        \n        .dashboard-container {{\n            max-width: 1600px;\n            margin: 0 auto;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n            padding: 20px;\n        }}\n        \n        h1 {{\n            text-align: center;\n            color: #333;\n            margin-bottom: 20px;\n            font-size: 28px;\n        }}\n        \n        .dashboard-content {{\n            display: flex;\n            gap: 20px;\n            align-items: flex-start;\n        }}\n        \n        .left-panel {{\n            flex: 2;\n        }}\n        \n        .right-panel {{\n            flex: 1;\n            background-color: #fafafa;\n            border-radius: 8px;\n            padding: 15px;\n        }}\n        \n        .gif-container {{\n            text-align: center;\n            background-color: #fff;\n            border-radius: 8px;\n            padding: 10px;\n            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }}\n        \n        .gif-container img {{\n            max-width: 100%;\n            height: auto;\n            border-radius: 5px;\n        }}\n        \n        .table-container {{\n            max-height: 700px;\n            overflow-y: auto;\n            border: 1px solid #ddd;\n            border-radius: 5px;\n            background-color: white;\n        }}\n        \n        table {{\n            width: 100%;\n            border-collapse: collapse;\n            font-size: 13px;\n        }}\n        \n        thead {{\n            position: sticky;\n            top: 0;\n            background-color: #4a86e8;\n            color: white;\n            z-index: 10;\n        }}\n        \n        th {{\n            padding: 12px 8px;\n            text-align: left;\n            font-weight: bold;\n            border-bottom: 2px solid #ddd;\n        }}\n        \n        td {{\n            padding: 10px 8px;\n            border-bottom: 1px solid #eee;\n        }}\n        \n        tbody tr:hover {{\n            background-color: #f5f5f5;\n        }}\n        \n        .spot-number {{\n            font-weight: bold;\n            padding: 5px 10px;\n            border-radius: 4px;\n            display: inline-block;\n        }}\n        \n        .spot-number.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .spot-number.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .license-plate {{\n            font-family: 'Courier New', monospace;\n            font-weight: bold;\n        }}\n        \n        .status-badge {{\n            padding: 4px 10px;\n            border-radius: 12px;\n            font-size: 11px;\n            font-weight: bold;\n            display: inline-block;\n        }}\n        \n        .status-badge.occupied {{\n            background-color: #ffcccc;\n            color: #cc0000;\n        }}\n        \n        .status-badge.vacant {{\n            background-color: #ccffcc;\n            color: #006600;\n        }}\n        \n        .summary-stats {{\n            margin-bottom: 15px;\n            padding: 15px;\n            background-color: #e3f2fd;\n            border-radius: 5px;\n        }}\n        \n        .summary-stats h3 {{\n            margin-bottom: 10px;\n            color: #1976d2;\n        }}\n        \n        .stat-item {{\n            margin: 5px 0;\n            font-size: 14px;\n        }}\n        \n        .stat-value {{\n            font-weight: bold;\n            font-size: 18px;\n            color: #1976d2;\n        }}\n        \n        .timestamp {{\n            text-align: center;\n            margin-top: 10px;\n            color: #666;\n            font-size: 12px;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <div class=\"dashboard-container\">\n        <h1>Parking Dashboard - Mini Project 3</h1>\n        \n        <div class=\"dashboard-content\">\n            <div class=\"left-panel\">\n                <div class=\"gif-container\">\n                    <img src=\"parking_animation.gif\" alt=\"Parking Animation\" id=\"parkingGif\">\n                    <div class=\"timestamp\" id=\"timestamp\">Time: {all_timestamps[0].strftime('%B %d, %Y at %I:%M %p')}</div>\n                </div>\n            </div>\n            \n            <div class=\"right-panel\">\n                <div class=\"summary-stats\">\n                    <h3>Parking Status Summary</h3>\n                    <div class=\"stat-item\">Total Spots: <span class=\"stat-value\">{total_count}</span></div>\n                    <div class=\"stat-item\">Occupied: <span class=\"stat-value\" id=\"occupiedCount\">{occupied_count}</span></div>\n                    <div class=\"stat-item\">Vacant: <span class=\"stat-value\" id=\"vacantCount\">{total_count - occupied_count}</span></div>\n                    <div class=\"stat-item\">Occupancy Rate: <span class=\"stat-value\" id=\"occupancyRate\">{int(occupied_count/total_count*100)}%</span></div>\n                </div>\n                \n                <h3 style=\"margin-bottom: 10px;\">Parking Spots Table</h3>\n                <div class=\"table-container\">\n                    <table id=\"spotsTable\">\n                        <thead>\n                            <tr>\n                                <th>Spot #</th>\n                                <th>License Plate</th>\n                                <th>Status</th>\n                            </tr>\n                        </thead>\n                        <tbody id=\"spotsTableBody\">\n                        </tbody>\n                    </table>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <script>\n        // Parking data for all timestamps\n        const timestampData = {json.dumps(timestamp_data, indent=8)};\n        \n        // Sorted list of all timestamps (matches GIF frame order)\n        const sortedTimestamps = {json.dumps(sorted_timestamps, indent=8)};\n        \n        // GIF frame duration in milliseconds (4 seconds per frame)\n        const FRAME_DURATION = 4000;\n        \n        // Current timestamp index (starts at 0)\n        let currentTimestampIndex = 0;\n        \n        // Function to update table with data for a specific timestamp\n        function updateTable(timestamp) {{\n            const data = timestampData[timestamp];\n            if (!data) return;\n            \n            const tbody = document.getElementById('spotsTableBody');\n            tbody.innerHTML = '';\n            \n            let occupiedCount = 0;\n            let vacantCount = 0;\n            \n            data.forEach(spot => {{\n                const row = document.createElement('tr');\n                \n                // Spot number with color coding\n                const spotNumberCell = document.createElement('td');\n                const spotNumberSpan = document.createElement('span');\n                spotNumberSpan.className = 'spot-number ' + spot.status;\n                spotNumberSpan.textContent = spot.spot_number;\n                spotNumberCell.appendChild(spotNumberSpan);\n                \n                // License plate\n                const plateCell = document.createElement('td');\n                if (spot.license_plate && spot.license_plate !== 'None') {{\n                    const plateSpan = document.createElement('span');\n                    plateSpan.className = 'license-plate';\n                    plateSpan.textContent = spot.license_plate;\n                    plateCell.appendChild(plateSpan);\n                }} else {{\n                    plateCell.textContent = '-';\n                    plateCell.style.color = '#999';\n                }}\n                \n                // Status badge\n                const statusCell = document.createElement('td');\n                const statusBadge = document.createElement('span');\n                statusBadge.className = 'status-badge ' + spot.status;\n                statusBadge.textContent = spot.status.charAt(0).toUpperCase() + spot.status.slice(1);\n                statusCell.appendChild(statusBadge);\n                \n                row.appendChild(spotNumberCell);\n                row.appendChild(plateCell);\n                row.appendChild(statusCell);\n                tbody.appendChild(row);\n                \n                if (spot.status === 'occupied') {{\n                    occupiedCount++;\n                }} else {{\n                    vacantCount++;\n                }}\n            }});\n            \n            // Update summary stats\n            const totalCount = data.length;\n            document.getElementById('occupiedCount').textContent = occupiedCount;\n            document.getElementById('vacantCount').textContent = vacantCount;\n            document.getElementById('occupancyRate').textContent = Math.round((occupiedCount / totalCount) * 100) + '%';\n            \n            // Update timestamp\n            const timestampDate = new Date(timestamp);\n            const timestampStr = timestampDate.toLocaleDateString('en-US', {{ \n                month: 'long', \n                day: 'numeric', \n                year: 'numeric' \n            }}) + ' at ' + timestampDate.toLocaleTimeString('en-US', {{ \n                hour: 'numeric', \n                minute: '2-digit',\n                hour12: true \n            }});\n            document.getElementById('timestamp').textContent = 'Time: ' + timestampStr;\n        }}\n        \n        // Initialize table with first timestamp (matches GIF start)\n        updateTable(sortedTimestamps[0]);\n        \n        // Synchronize table updates with GIF animation\n        // Update table every 4 seconds to match GIF frame rate\n        setInterval(() => {{\n            // Move to next timestamp (loop back to start when reaching end)\n            currentTimestampIndex = (currentTimestampIndex + 1) % sortedTimestamps.length;\n            const currentTimestamp = sortedTimestamps[currentTimestampIndex];\n            updateTable(currentTimestamp);\n        }}, FRAME_DURATION);\n        \n        // Reset to first frame when GIF loops (GIF loop detection is tricky, so we'll sync manually)\n        // The GIF loops, so we reset our index to match\n        const gifElement = document.getElementById('parkingGif');\n        if (gifElement) {{\n            // Reset to first frame every GIF loop cycle (60 frames * 4 seconds = 240 seconds)\n            const gifLoopDuration = sortedTimestamps.length * FRAME_DURATION;\n            setInterval(() => {{\n                currentTimestampIndex = 0;\n                updateTable(sortedTimestamps[0]);\n            }}, gifLoopDuration);\n        }}\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    # Save HTML file\n    output_file = 'parking_dashboard.html'\n    with open(output_file, 'w', encoding='utf-8') as f:\n        f.write(html_content)\n    \n    print(f\"\\nâœ“ Interactive dashboard created: {output_file}\")\n    print(f\"  - Opens the animated GIF\")\n    print(f\"  - Shows live-updating table with color-coded spots\")\n    print(f\"  - Red for occupied spots, green for vacant spots\")\n    print(f\"  - License plates displayed when occupied\")\n    print(f\"\\nOpen {output_file} in your web browser to view the dashboard!\")\n    \n    return output_file\n\nif __name__ == \"__main__\":\n    try:\n        create_interactive_dashboard()\n    except Exception as e:\n        print(f\"\\nâœ— Error creating dashboard: {e}\")\n        import traceback\n        traceback.print_exc()\n\n"},{"path":"visualize_parking.py","size":5583,"mtime":1765482683702,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:53:07.296Z","tree_hash":"78dffbf307bb2d06a425a4e282bf8f34d2700e7b803a0d9a5f1e2e790f87882f","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765482784348,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:53:12.302Z","tree_hash":"5d9c7e862ffb088280bf236fd5c3fe3a4ca6bf6f7d85ac42954385e41b9da065","added":[],"modified":[{"path":"parking_animation.gif","size":3096601,"mtime":1765482788628,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:53:22.308Z","tree_hash":"29b0d2acd4f59314fc7b952173627d35faa5d6e0e0199f341f55aa324857d3a8","added":[],"modified":[{"path":"parking_dashboard.html","size":396182,"mtime":1765482800582,"ext":"html"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:58:12.493Z","tree_hash":"ef6d41537b58ae48cacf0acf1200961ddf76b360e1424d5983b3aa47024bbdaf","added":[],"modified":[{"path":"visualize_parking.py","size":5684,"mtime":1765483090250,"ext":"py","content":"install pandas\ninstall matplotlib\ninstall PIL\ninstall imageio\ninstall os\ninstall numpy\ninstall io\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:58:42.520Z","tree_hash":"d4408cf4df6912eec76b3e67442a2d1e2cf06615f045e56ffa5fef33607e6e78","added":[],"modified":[{"path":"visualize_parking.py","size":5693,"mtime":1765483121071,"ext":"py","content":"pip install pandas\ninstall matplotlib\ninstall PIL\ninstall imageio\ninstall os\ninstall numpy\ninstall imageio\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T19:58:57.532Z","tree_hash":"28b11c27646e520ef4e40ec241cf2a80feeca30ced313a42433c7ca62cd40743","added":[],"modified":[{"path":"visualize_parking.py","size":5718,"mtime":1765483134886,"ext":"py","content":"pip install pandas\npip install matplotlib\npip install PIL\npip install imageio\npip install os\npip install numpy\npip install imageio\n\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:02:22.694Z","tree_hash":"832de74581fc97b617f08c2c3c2076ff29ad786191b58472689209960851f0f7","added":[],"modified":[{"path":"visualize_parking.py","size":5647,"mtime":1765483339633,"ext":"py","content":"pip install pandas matplotlib pillow imageio numpy openpyxl\n\n\n\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:05:42.851Z","tree_hash":"b5ac79a3e369b3b92cf90c0ac710a7383746492e6e0248dd28e14295180bc9f6","added":[],"modified":[{"path":"visualize_parking.py","size":5583,"mtime":1765483538003,"ext":"py","content":"import pandas as pd\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nimport matplotlib.offsetbox as offsetbox\nimport imageio\nimport os\nimport numpy as np\nfrom io import BytesIO\n\ndef main():\n    # Load Data: Read the excel file into a pandas dataframe\n    df = pd.read_excel('ride_hailing.xlsx')\n\n    # Basic Processing\n    # Create a new column called status\n    # If reservation_id has any text or numbers, status should be 'occupied', otherwise 'vacant'\n    df['status'] = df['reservation_id'].apply(\n        lambda x: 'occupied' if pd.notna(x) and str(x).strip() != '' else 'vacant'\n    )\n\n    # Make sure current_time column is understood as a date and time\n    df['current_time'] = pd.to_datetime(df['current_time'])\n\n    # Load background image\n    bg_image = Image.open('map.png')\n    img_width, img_height = bg_image.size\n\n    # Get unique timestamps sorted\n    unique_timestamps = sorted(df['current_time'].unique())\n\n    print(f\"Creating animation with {len(unique_timestamps)} frames...\")\n\n    # Create function to draw a frame for a given timestamp\n    def create_frame(timestamp):\n        # Filter data for the specific timestamp\n        plot_data = df[df['current_time'] == timestamp]\n        \n        # Generate scatterplot with larger figure size\n        fig, ax = plt.subplots(figsize=(16, 12))\n        \n        # Set background image - display image as-is without flipping\n        ax.imshow(bg_image, extent=[0, img_width, 0, img_height], \n                  aspect='equal', alpha=1.0, zorder=0)\n        \n        # Set axis limits to show the entire image\n        ax.set_xlim(0, img_width)\n        ax.set_ylim(0, img_height)\n        \n        # Plot vacant spots as gray dots\n        vacant_data = plot_data[plot_data['status'] == 'vacant']\n        if len(vacant_data) > 0:\n            ax.scatter(\n                vacant_data['x'],\n                vacant_data['y'],\n                c='gray',\n                label='Vacant',\n                alpha=0.8,\n                s=100,\n                zorder=2,\n                edgecolors='black',\n                linewidths=1.5\n            )\n        \n        # Plot occupied spots using license plate images\n        occupied_data = plot_data[plot_data['status'] == 'occupied']\n        for idx, row in occupied_data.iterrows():\n            plate_number = row['plate_number']\n            x_coord = row['x']\n            y_coord = row['y']\n            \n            # Load license plate image if it exists\n            plate_path = f'plates/{plate_number}.png'\n            if os.path.exists(plate_path):\n                try:\n                    plate_img = Image.open(plate_path)\n                    # Resize the plate image to appropriate size\n                    # Adjust the resize factor as needed to fit nicely on the map\n                    plate_img.thumbnail((80, 40), Image.Resampling.LANCZOS)\n                    \n                    # Create offset box with the license plate image\n                    imagebox = offsetbox.OffsetImage(plate_img, zoom=1.0)\n                    ab = offsetbox.AnnotationBbox(imagebox, (x_coord, y_coord), \n                                                 frameon=False, pad=0)\n                    ax.add_artist(ab)\n                except Exception as e:\n                    # If image can't be loaded, fall back to red dot\n                    print(f\"Warning: Could not load {plate_path}: {e}\")\n                    ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                              edgecolors='darkred', linewidths=1.5)\n            else:\n                # If plate image doesn't exist, use red dot\n                ax.scatter(x_coord, y_coord, c='red', s=100, zorder=2, \n                          edgecolors='darkred', linewidths=1.5)\n        \n        # Remove white background\n        ax.set_facecolor('none')\n        fig.patch.set_facecolor('none')\n        \n        # Hide x and y axis numbers and ticks\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        \n        # Remove grid lines\n        ax.grid(False)\n        \n        # Add title showing date and time\n        title_text = f'Parking Status - {timestamp.strftime(\"%B %d, %Y at %I:%M %p\")}'\n        ax.set_title(title_text, fontsize=18, fontweight='bold', pad=20, color='black')\n        \n        # Create a simple legend\n        ax.legend(loc='upper right', fontsize=14, framealpha=0.9, edgecolor='black', \n                  title='Parking Status', title_fontsize=14)\n        \n        plt.tight_layout()\n        \n        # Convert figure to image array for GIF creation\n        buf = BytesIO()\n        fig.savefig(buf, format='png', dpi=100, bbox_inches='tight', \n                    facecolor='white', transparent=False)\n        buf.seek(0)\n        image_array = np.array(Image.open(buf))\n        buf.close()\n        \n        plt.close(fig)\n        \n        return image_array\n\n    # Create frames for all timestamps\n    frames = []\n    for i, timestamp in enumerate(unique_timestamps):\n        print(f\"Creating frame {i+1}/{len(unique_timestamps)}: {timestamp}\")\n        frame = create_frame(timestamp)\n        frames.append(frame)\n\n    # Create animated GIF\n    # Each frame displays for 4 seconds (duration = 4.0) - slower for better viewing\n    print(\"Creating animated GIF...\")\n    imageio.mimsave('parking_animation.gif', frames, duration=4.0, loop=0)\n\n    print(f\"Animation saved as 'parking_animation.gif'\")\n    print(f\"Total frames: {len(frames)}\")\n    print(f\"Duration per frame: 4 seconds\")\n\nif __name__ == \"__main__\":\n    main()\n"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:07:07.924Z","tree_hash":"c876337c40f6b6d6ba97b0076a6618ad9bac0e7dc771032aeca38ab51feb7b24","added":[],"modified":[{"path":"parking_animation.gif","size":3096601,"mtime":1765483627730,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:08:22.984Z","tree_hash":"79dc8cee4d4897541effc9cf969d9afa8d69072582883906c97d6accd38a5680","added":[],"modified":[{"path":"parking_animation.gif","size":0,"mtime":1765483699485,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:08:27.990Z","tree_hash":"206b7afa7670a3712eac2db876d841aa0e5d48635fb612a95386c129bdb5c13b","added":[],"modified":[{"path":"parking_animation.gif","size":3096601,"mtime":1765483703258,"ext":"gif"},{"path":"parking_dashboard.html","size":396182,"mtime":1765483707632,"ext":"html"}],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:11:13.385Z","tree_hash":"8e30a266a50eadf37f1db982660e07f3e3d06c469b4b5cc295e3175c08cde465","added":[],"modified":[],"removed":[{"path":"parking_animation.gif","size":0,"mtime":0,"ext":"gif","content":null}],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:11:43.407Z","tree_hash":"79d93aa81495a68d74ab7ad6c774651079ba28a4488020bac8cb78c188b3b48c","added":[{"path":"parking_animation.gif","size":0,"mtime":1765483901441,"ext":"gif"}],"modified":[],"removed":[],"experiment_id":"EXP00004"}},{"endpoint":"/structure/snapshot","body":{"workspace_id":"L1VzZXJzL2FudGhv","ts":"2025-12-11T20:11:48.414Z","tree_hash":"0ba5e355dc8f2a9c378ee8fc73e32cec506204063707c9ab9d93b1234b52fe5c","added":[],"modified":[{"path":"parking_animation.gif","size":3096601,"mtime":1765483905378,"ext":"gif"}],"removed":[],"experiment_id":"EXP00004"}}]